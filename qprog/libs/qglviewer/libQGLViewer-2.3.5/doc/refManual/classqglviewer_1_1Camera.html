<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libQGLViewer: Camera Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link rel="shortcut icon" href="../images/qglviewer.ico" type="image/x-icon" />
<link rel="icon" href="../images/qglviewer.icon.png" type="image/png" />
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="../index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>

    </ul>
  </div>
  </div>
</div>
<div class="contents">
<h1>Camera Class Reference</h1><!-- doxytag: class="qglviewer::Camera" -->
<p>A perspective or orthographic camera.  
<a href="#_details">More...</a></p>

<p><a href="classqglviewer_1_1Camera-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a1d1cfd8ffb84e947f82999c682b666a7">Type</a> { <a class="el" href="classqglviewer_1_1Camera.html#a1d1cfd8ffb84e947f82999c682b666a7a2c5d7801888c03752f28943ac85d805f">PERSPECTIVE</a>, 
<a class="el" href="classqglviewer_1_1Camera.html#a1d1cfd8ffb84e947f82999c682b666a7ae7bf29f117630a30ba5ffc75b33ac624">ORTHOGRAPHIC</a>
 }</td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#aa3f3efcb2fcc75de885df29041103cd2">Camera</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#ab921e886e6f14e117eb8099ccb0a3775">~Camera</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a43d24da01076c4cea5f3dbde85e8482c">Camera</a> (const Camera &amp;camera)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Camera &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a0f87e84ad3356493738d4fc8331c7362">operator=</a> (const Camera &amp;camera)</td></tr>
<tr><td colspan="2"><h2>Position and orientation</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp0921bffa34e5447a81904937f14dc3c9"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqglviewer_1_1Vec.html">Vec</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#abc38a05a597e07c9ff525122682adc50">position</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqglviewer_1_1Vec.html">Vec</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a9cd2e746e7379b08fbaeea0ced76e1d7">upVector</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqglviewer_1_1Vec.html">Vec</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#aac10e453c166209b4e6c14c0266651c7">viewDirection</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqglviewer_1_1Vec.html">Vec</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a99f766869c7cc9faaf9a5337db6f223c">rightVector</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqglviewer_1_1Quaternion.html">Quaternion</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a691af39b54669fad8b4e73599de22094">orientation</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#ab21e4c76205431bdeba645a5f258dce9">setFromModelViewMatrix</a> (const GLdouble *const modelViewMatrix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#ac49280735bce44665a4eabb166f10fcd">setFromProjectionMatrix</a> (const float matrix[12])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a212edb01759f542f356c5d62e4a3f821">setPosition</a> (const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;pos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a3862c502f5afc626af2ff582390bc868">setOrientation</a> (const <a class="el" href="classqglviewer_1_1Quaternion.html">Quaternion</a> &amp;q)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a1842836742cf1ed8a33f32a863a5a05e">setOrientation</a> (float theta, float phi)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#ab442b71a46297223ae12b163653eeb7e">setUpVector</a> (const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;up, bool noMove=true)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a066c4058970a008d0d0a8ff442d117f6">setViewDirection</a> (const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;direction)</td></tr>
<tr><td colspan="2"><h2>Frustum</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp6662e570aa6f4c7113c69b4c240dab96"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqglviewer_1_1Camera.html#a1d1cfd8ffb84e947f82999c682b666a7">Type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#afbd0fa31db28593e9669c3c56711c0a7">type</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a89f1a2e62f7edf51de2d1c077ea5d330">fieldOfView</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a957cf1049788f7aba3dd16f20f565960">horizontalFieldOfView</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a915589f4d93e15d110444ed9b3464fa1">aspectRatio</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a80386c5943505b915246563262825d8e">screenWidth</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a9fb925ffbf82e93898ae6db366a8d794">screenHeight</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a5034f21055f864c1ade7d86fec209348">getViewport</a> (GLint viewport[4]) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a27f2dfd157643704c48630515a7f811f">pixelGLRatio</a> (const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;position) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a4c29c26071ddbe8512d478511e04a93e">zNearCoefficient</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#acd07c1b9464b935ad21bb38b7c27afca">zClippingCoefficient</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a419a57556a6681c3a0489c847d687ea5">zNear</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#aa7461df81c1ea0384d4c64723eb7b949">zFar</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#affe84ed52b08d5d1d3dfdb87fe9242fa">getOrthoWidthHeight</a> (GLdouble &amp;halfWidth, GLdouble &amp;halfHeight) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a1450258d117908a71908a72184136e41">getFrustumPlanesCoefficients</a> (GLdouble coef[6][4]) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a608e58a2f9fb7e497f91662a6e9ae4cc">setType</a> (<a class="el" href="classqglviewer_1_1Camera.html#a1d1cfd8ffb84e947f82999c682b666a7">Type</a> type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a524f0183a127bb004defe3c2f7614e4c">setFieldOfView</a> (float fov)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a017ace2ed5f67b6aeaef5c9a47b5f014">setHorizontalFieldOfView</a> (float hfov)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a3394c425f95c5649b1e2e532dbd97fa7">setFOVToFitScene</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a5b191e9b12b704a05302b5d922792e9c">setAspectRatio</a> (float aspect)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a504c573cdd26be8b717a6da9fdb41812">setScreenWidthAndHeight</a> (int width, int height)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a1d478610f928ecc4597c56d677d908b5">setZNearCoefficient</a> (float coef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a62ab18396bd8c212ec7b90dc156b59d7">setZClippingCoefficient</a> (float coef)</td></tr>
<tr><td colspan="2"><h2>Scene radius and center</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp575f8e7230ff2b9ae0b77a50582a0b07"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a58c17044cc4a601c6b446bf5e83513f9">sceneRadius</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqglviewer_1_1Vec.html">Vec</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a87bccbfd40649310f3da369af02d50b1">sceneCenter</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a253932bd8634348f9c189ab4c9b280b5">distanceToSceneCenter</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a33c70507fea15c3ea49a561b743ed822">setSceneRadius</a> (float radius)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a9185df6d9e8fbc108f83c5355f5e7b33">setSceneCenter</a> (const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;center)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a338c3360223f5fb20e2248208d2f32bf">setSceneCenterFromPixel</a> (const QPoint &amp;pixel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#af3a1c2682cba52d6339d2f565ea1d0ee">setSceneBoundingBox</a> (const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;min, const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;max)</td></tr>
<tr><td colspan="2"><h2>Revolve Around Point</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp9c68c9d9284a37c4d2d696708189b3ca"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqglviewer_1_1Vec.html">Vec</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#afd168442e2a05bd41881936fb722b5fe">revolveAroundPoint</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a546bc081d6116ff848e6fc25a2329e08">setRevolveAroundPoint</a> (const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;rap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a1710d7aa9fc8dd96f88bba9a1ae3eed7">setRevolveAroundPointFromPixel</a> (const QPoint &amp;pixel)</td></tr>
<tr><td colspan="2"><h2>Associated frame</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp0423c5a05ec9388de91720cd2ce43216"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqglviewer_1_1ManipulatedCameraFrame.html">ManipulatedCameraFrame</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#ad367db656b03fe0bc87b021801d66b75">frame</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a809bad30c861f4f6f74228fb59340f90">setFrame</a> (<a class="el" href="classqglviewer_1_1ManipulatedCameraFrame.html">ManipulatedCameraFrame</a> *const mcf)</td></tr>
<tr><td colspan="2"><h2>KeyFramed paths</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpf38e372c1ab444d6a16d087bd06df8f7"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html">KeyFrameInterpolator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#abfbef567a6bbb9163b31c6f46238e4de">keyFrameInterpolator</a> (int i) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a049b63c8c9ef48e24446ce44a3bd32b5">setKeyFrameInterpolator</a> (int i, <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html">KeyFrameInterpolator</a> *const kfi)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a804ee001a41c3ddc33948447fc555cec">addKeyFrameToPath</a> (int i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a4eb47bb1cf02f806f1f355f63b445818">playPath</a> (int i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a8a75fa050d365ba249e8dcd439670aac">deletePath</a> (int i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#ae0329e473f00bb56f1e9949b8423ecbf">resetPath</a> (int i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#aeea4caff561e6b1d8fe4b3d8efe4ae87">drawAllPaths</a> ()</td></tr>
<tr><td colspan="2"><h2>OpenGL matrices</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpd88e1406b3b0ed6b68732c840e7d85b0"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a98a0679a22f005bbd8cc19756507cc9a">loadProjectionMatrix</a> (bool reset=true) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a81053f822008b76bff7b1a41dceedf53">loadModelViewMatrix</a> (bool reset=true) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#ae51b6c486fe6448453369174bbea8055">computeProjectionMatrix</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a0dad4baab6008e5a94e8a2fa83ec0f05">computeModelViewMatrix</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a79dac3c1bcb983c9025710b333f063a3">loadProjectionMatrixStereo</a> (bool leftBuffer=true) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a47c0f19a566d045a2872b44014be8392">loadModelViewMatrixStereo</a> (bool leftBuffer=true) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a97ff5cf330a6c24d6d49308aedd638bc">getProjectionMatrix</a> (GLdouble m[16]) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#aa1d631d6e368a7aa14656b7511787786">getModelViewMatrix</a> (GLdouble m[16]) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#adeb5e39686b9fcb3db090dff84c13be4">getModelViewProjectionMatrix</a> (GLdouble m[16]) const </td></tr>
<tr><td colspan="2"><h2>Drawing</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp681d72abce5de4f856e71bfb1856796b"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a1636e20e6910ded1c9a5860ba91f397e">draw</a> (bool drawFarPlane=true, float scale=1.0) const </td></tr>
<tr><td colspan="2"><h2>World to Camera coordinate systems conversions</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpf918e6cb8960d077db6604fc974ccef0"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqglviewer_1_1Vec.html">Vec</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a5dd8eca926558c252d7552d85079880a">cameraCoordinatesOf</a> (const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;src) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqglviewer_1_1Vec.html">Vec</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a123ad9bda6d715b5370650c2514896ab">worldCoordinatesOf</a> (const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;src) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#abadd060aa34d51a940575b58d256dca4">getCameraCoordinatesOf</a> (const float src[3], float res[3]) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#ae1b0a45b7cd3a071c4ef88ed608511fd">getWorldCoordinatesOf</a> (const float src[3], float res[3]) const </td></tr>
<tr><td colspan="2"><h2>2D screen to 3D world coordinate systems conversions</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpe15edcd1bd14a127c6b4ab912ab83a72"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqglviewer_1_1Vec.html">Vec</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#ac4dc649d17bd2ae8664a7f4fdd50360f">projectedCoordinatesOf</a> (const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;src, const <a class="el" href="classqglviewer_1_1Frame.html">Frame</a> *frame=NULL) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqglviewer_1_1Vec.html">Vec</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a42577d3077e22b4726d78b3db3bba50d">unprojectedCoordinatesOf</a> (const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;src, const <a class="el" href="classqglviewer_1_1Frame.html">Frame</a> *frame=NULL) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#ae167e3b955401e11bbbf0fc25f52e3ee">getProjectedCoordinatesOf</a> (const float src[3], float res[3], const <a class="el" href="classqglviewer_1_1Frame.html">Frame</a> *frame=NULL) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a222deedc6fa32ab78d0a338eaa312f1f">getUnprojectedCoordinatesOf</a> (const float src[3], float res[3], const <a class="el" href="classqglviewer_1_1Frame.html">Frame</a> *frame=NULL) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a706d401cffa41e0e30864e59007f005f">convertClickToLine</a> (const QPoint &amp;pixel, <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;orig, <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;dir) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqglviewer_1_1Vec.html">Vec</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a90459767f782c80086ad7cff90a40b5a">pointUnderPixel</a> (const QPoint &amp;pixel, bool &amp;found) const </td></tr>
<tr><td colspan="2"><h2>Fly speed</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp797e9c1e0c0519435aed97012c48689d"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#ac1758b72dab0895b9340fa833e62b802">flySpeed</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a02765efeaae1ef24f9d899f0d1d9ca09">setFlySpeed</a> (float speed)</td></tr>
<tr><td colspan="2"><h2>Stereo parameters</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp3aceabdd3f0fb4b0ff38aa3fc1ffdd99"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#ad36e74de9c4020f951ea1a04e53a192d">IODistance</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a2cbb7d182c56732a6129936c5dd19d64">physicalDistanceToScreen</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a8418799b4eeb22cbc1a157d488dcf09c">physicalScreenWidth</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#af201ce62f669c8944a276a2615951379">focusDistance</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a6cd81fe74a9dfe5c7124d00341ad0234">setIODistance</a> (float distance)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#aa88668546aa531dc0702d1b005904bcf">setPhysicalDistanceToScreen</a> (float distance)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a34911cda1cc1bc13336024c844ff4401">setPhysicalScreenWidth</a> (float width)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a863ffb0284b534d5c57ac64a98e5e49a">setFocusDistance</a> (float distance)</td></tr>
<tr><td colspan="2"><h2>XML representation</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp387fd844b3a8c7b2f9fcbfeb7f61313b"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual QDomElement&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a48e0e2dd26cd96418c8b889ceabe80f6">domElement</a> (const QString &amp;name, QDomDocument &amp;document) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#acd13d2ddeca530cb9f26ead47f7d25d3">initFromDOMElement</a> (const QDomElement &amp;element)</td></tr>
<tr><td colspan="2"><h2>Positioning tools</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp1af5c8a060b5dc9f6fd3392817b98e49"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#aafe147ffa75738c296c729d9b5026446">lookAt</a> (const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;target)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#ada8dd7d2346ebf46ed1f9822a8418df2">showEntireScene</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a424fbe98af0ca295c692d8d4ae73ceec">fitSphere</a> (const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;center, float radius)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a65a284702aab36f853d59ce6c7a082b9">fitBoundingBox</a> (const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;min, const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;max)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#ac49a71148d1d501310026f6f6f76d471">fitScreenRegion</a> (const QRect &amp;rectangle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#abf37eb8d64d09f93771b42b95cad00f6">centerScene</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a9e2b0c2d37f9176629d737faf431b51c">interpolateToZoomOnPixel</a> (const QPoint &amp;pixel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a8a6201a1c2deca60a917e5351e549bb0">interpolateToFitScene</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqglviewer_1_1Camera.html#a37dee575e0fdf56909e1779e20383e97">interpolateTo</a> (const <a class="el" href="classqglviewer_1_1Frame.html">Frame</a> &amp;fr, float duration)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A perspective or orthographic camera. </p>
<p>A Camera defines some intrinsic parameters (<a class="el" href="classqglviewer_1_1Camera.html#a89f1a2e62f7edf51de2d1c077ea5d330">fieldOfView()</a>, <a class="el" href="classqglviewer_1_1Camera.html#abc38a05a597e07c9ff525122682adc50">position()</a>, <a class="el" href="classqglviewer_1_1Camera.html#aac10e453c166209b4e6c14c0266651c7">viewDirection()</a>, <a class="el" href="classqglviewer_1_1Camera.html#a9cd2e746e7379b08fbaeea0ced76e1d7">upVector()</a>...) and useful positioning tools that ease its placement (<a class="el" href="classqglviewer_1_1Camera.html#ada8dd7d2346ebf46ed1f9822a8418df2">showEntireScene()</a>, <a class="el" href="classqglviewer_1_1Camera.html#a424fbe98af0ca295c692d8d4ae73ceec">fitSphere()</a>, <a class="el" href="classqglviewer_1_1Camera.html#aafe147ffa75738c296c729d9b5026446">lookAt()</a>...). It exports its associated OpenGL projection and modelview matrices and can interactively be modified using the mouse.</p>
<h3>Mouse manipulation</h3>
<p>The <a class="el" href="classqglviewer_1_1Camera.html#abc38a05a597e07c9ff525122682adc50">position()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a691af39b54669fad8b4e73599de22094">orientation()</a> of the Camera are defined by a <a class="el" href="classqglviewer_1_1ManipulatedCameraFrame.html" title="The ManipulatedCameraFrame class represents a ManipulatedFrame with Camera specific...">ManipulatedCameraFrame</a> (retrieved using <a class="el" href="classqglviewer_1_1Camera.html#ad367db656b03fe0bc87b021801d66b75">frame()</a>). These methods are just convenient wrappers to the equivalent <a class="el" href="classqglviewer_1_1Frame.html" title="The Frame class represents a coordinate system, defined by a position and an orientation...">Frame</a> methods. This also means that the Camera <a class="el" href="classqglviewer_1_1Camera.html#ad367db656b03fe0bc87b021801d66b75">frame()</a> can be attached to a <a class="el" href="classqglviewer_1_1Frame.html#a9794b079db5f492e8804631d3d23baec">Frame::referenceFrame()</a> which enables complex Camera setups.</p>
<p>Different displacements can be performed using the mouse. The list of possible actions is defined by the <a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875">QGLViewer::MouseAction</a> enum. Use <a class="el" href="classQGLViewer.html#a218f2279fd64d5841b5ae2fc67d74274">QGLViewer::setMouseBinding()</a> to attach a specific action to an arbitrary mouse button-state key binding. These actions are detailed in the <a href="../mouse.html">mouse page</a>.</p>
<p>The default button binding are: <a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875a3dcfe0046eb5876e287dbf0914819b16">ROTATE</a> (left), <a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875a604adefe799fe794cab6b76ed1108201">ZOOM</a> (middle) and <a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875abc6501410409b0638909b580970b35f7">TRANSLATE</a> (right). With this configuration, the Camera <em>observes</em> a scene and rotates around its <a class="el" href="classqglviewer_1_1Camera.html#afd168442e2a05bd41881936fb722b5fe">revolveAroundPoint()</a>. You can switch between this mode and a fly mode using the <a class="el" href="classQGLViewer.html#a7a90ec0b49f9586addb5eed9026077c1a91b759170cb0389695a3c219a9a69073">CAMERA_MODE</a> (see <a class="el" href="classQGLViewer.html#a17ea00dd30fb78086cf7e22bc2f10695">QGLViewer::toggleCameraMode()</a>) keyboard shortcut (default is 'Space').</p>
<h3>Other functionalities</h3>
<p>The <a class="el" href="classqglviewer_1_1Camera.html#afbd0fa31db28593e9669c3c56711c0a7">type()</a> of the Camera can be <a class="el" href="classqglviewer_1_1Camera.html#a1d1cfd8ffb84e947f82999c682b666a7ae7bf29f117630a30ba5ffc75b33ac624">Camera::ORTHOGRAPHIC</a> or <a class="el" href="classqglviewer_1_1Camera.html#a1d1cfd8ffb84e947f82999c682b666a7a2c5d7801888c03752f28943ac85d805f">Camera::PERSPECTIVE</a> (see <a class="el" href="classqglviewer_1_1Camera.html#a1d1cfd8ffb84e947f82999c682b666a7">Type()</a>). <a class="el" href="classqglviewer_1_1Camera.html#a89f1a2e62f7edf51de2d1c077ea5d330">fieldOfView()</a> is meaningless with <a class="el" href="classqglviewer_1_1Camera.html#a1d1cfd8ffb84e947f82999c682b666a7ae7bf29f117630a30ba5ffc75b33ac624">Camera::ORTHOGRAPHIC</a>.</p>
<p>The near and far planes of the Camera are fitted to the scene and determined from <a class="el" href="classQGLViewer.html#a58c17044cc4a601c6b446bf5e83513f9">QGLViewer::sceneRadius()</a>, <a class="el" href="classQGLViewer.html#a5a0503bc22a710f96bfd779eaf538bab">QGLViewer::sceneCenter()</a> and <a class="el" href="classqglviewer_1_1Camera.html#acd07c1b9464b935ad21bb38b7c27afca">zClippingCoefficient()</a> by the <a class="el" href="classqglviewer_1_1Camera.html#a419a57556a6681c3a0489c847d687ea5">zNear()</a> and <a class="el" href="classqglviewer_1_1Camera.html#aa7461df81c1ea0384d4c64723eb7b949">zFar()</a> methods. Reasonable values on the scene extends hence have to be provided to the <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a> in order for the Camera to correctly display the scene. High level positioning methods also use this information (<a class="el" href="classqglviewer_1_1Camera.html#ada8dd7d2346ebf46ed1f9822a8418df2">showEntireScene()</a>, <a class="el" href="classqglviewer_1_1Camera.html#abf37eb8d64d09f93771b42b95cad00f6">centerScene()</a>...).</p>
<p>A Camera holds <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html" title="A keyFrame Catmull-Rom Frame interpolator.">KeyFrameInterpolator</a> that can be used to save Camera positions and paths. You can interactively <a class="el" href="classqglviewer_1_1Camera.html#a804ee001a41c3ddc33948447fc555cec">addKeyFrameToPath()</a> to a given path using the default <code>Alt+F</code>[1-12] shortcuts. Use <a class="el" href="classqglviewer_1_1Camera.html#a4eb47bb1cf02f806f1f355f63b445818">playPath()</a> to make the Camera follow the path (default shortcut is F[1-12]). See the <a href="../keyboard.html">keyboard page</a> for details on key customization.</p>
<p>Use <a class="el" href="classqglviewer_1_1Camera.html#a5dd8eca926558c252d7552d85079880a">cameraCoordinatesOf()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a123ad9bda6d715b5370650c2514896ab">worldCoordinatesOf()</a> to convert to and from the Camera <a class="el" href="classqglviewer_1_1Camera.html#ad367db656b03fe0bc87b021801d66b75">frame()</a> coordinate system. <a class="el" href="classqglviewer_1_1Camera.html#ac4dc649d17bd2ae8664a7f4fdd50360f">projectedCoordinatesOf()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a42577d3077e22b4726d78b3db3bba50d">unprojectedCoordinatesOf()</a> will convert from screen to 3D coordinates. <a class="el" href="classqglviewer_1_1Camera.html#a706d401cffa41e0e30864e59007f005f">convertClickToLine()</a> is very useful for analytical object selection.</p>
<p>Stereo display is possible on machines with quad buffer capabilities (with <a class="el" href="classqglviewer_1_1Camera.html#a1d1cfd8ffb84e947f82999c682b666a7a2c5d7801888c03752f28943ac85d805f">Camera::PERSPECTIVE</a> <a class="el" href="classqglviewer_1_1Camera.html#afbd0fa31db28593e9669c3c56711c0a7">type()</a> only). Test the <a href="../examples/stereoViewer.html">stereoViewer example</a> to check.</p>
<p>A Camera can also be used outside of a <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a> or even without OpenGL for its coordinate system conversion capabilities. Note however that some of them explicitly rely on the presence of a Z-buffer. </p>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a1d1cfd8ffb84e947f82999c682b666a7"></a><!-- doxytag: member="qglviewer::Camera::Type" ref="a1d1cfd8ffb84e947f82999c682b666a7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classqglviewer_1_1Camera.html#a1d1cfd8ffb84e947f82999c682b666a7">Type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enumerates the two possible types of Camera.</p>
<p>See <a class="el" href="classqglviewer_1_1Camera.html#afbd0fa31db28593e9669c3c56711c0a7">type()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a608e58a2f9fb7e497f91662a6e9ae4cc">setType()</a>. This type mainly defines different Camera projection matrix (see <a class="el" href="classqglviewer_1_1Camera.html#a98a0679a22f005bbd8cc19756507cc9a">loadProjectionMatrix()</a>). Many other methods (<a class="el" href="classqglviewer_1_1Camera.html#a90459767f782c80086ad7cff90a40b5a">pointUnderPixel()</a>, <a class="el" href="classqglviewer_1_1Camera.html#a706d401cffa41e0e30864e59007f005f">convertClickToLine()</a>, <a class="el" href="classqglviewer_1_1Camera.html#ac4dc649d17bd2ae8664a7f4fdd50360f">projectedCoordinatesOf()</a>, <a class="el" href="classqglviewer_1_1Camera.html#a27f2dfd157643704c48630515a7f811f">pixelGLRatio()</a>...) take this Type into account. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a1d1cfd8ffb84e947f82999c682b666a7a2c5d7801888c03752f28943ac85d805f"></a><!-- doxytag: member="PERSPECTIVE" ref="a1d1cfd8ffb84e947f82999c682b666a7a2c5d7801888c03752f28943ac85d805f" args="" -->PERSPECTIVE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a1d1cfd8ffb84e947f82999c682b666a7ae7bf29f117630a30ba5ffc75b33ac624"></a><!-- doxytag: member="ORTHOGRAPHIC" ref="a1d1cfd8ffb84e947f82999c682b666a7ae7bf29f117630a30ba5ffc75b33ac624" args="" -->ORTHOGRAPHIC</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa3f3efcb2fcc75de885df29041103cd2"></a><!-- doxytag: member="qglviewer::Camera::Camera" ref="aa3f3efcb2fcc75de885df29041103cd2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Camera </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Default constructor.</p>
<p><a class="el" href="classqglviewer_1_1Camera.html#a87bccbfd40649310f3da369af02d50b1">sceneCenter()</a> is set to (0,0,0) and <a class="el" href="classqglviewer_1_1Camera.html#a58c17044cc4a601c6b446bf5e83513f9">sceneRadius()</a> is set to 1.0. <a class="el" href="classqglviewer_1_1Camera.html#afbd0fa31db28593e9669c3c56711c0a7">type()</a> is <a class="el" href="classqglviewer_1_1Camera.html#a1d1cfd8ffb84e947f82999c682b666a7a2c5d7801888c03752f28943ac85d805f">Camera::PERSPECTIVE</a>, with a <code>M_PI/4</code> <a class="el" href="classqglviewer_1_1Camera.html#a89f1a2e62f7edf51de2d1c077ea5d330">fieldOfView()</a>.</p>
<p>See <a class="el" href="classqglviewer_1_1Camera.html#ad36e74de9c4020f951ea1a04e53a192d">IODistance()</a>, <a class="el" href="classqglviewer_1_1Camera.html#a2cbb7d182c56732a6129936c5dd19d64">physicalDistanceToScreen()</a>, <a class="el" href="classqglviewer_1_1Camera.html#a8418799b4eeb22cbc1a157d488dcf09c">physicalScreenWidth()</a> and <a class="el" href="classqglviewer_1_1Camera.html#af201ce62f669c8944a276a2615951379">focusDistance()</a> documentations for default stereo parameter values. </p>

</div>
</div>
<a class="anchor" id="ab921e886e6f14e117eb8099ccb0a3775"></a><!-- doxytag: member="qglviewer::Camera::~Camera" ref="ab921e886e6f14e117eb8099ccb0a3775" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~Camera </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Virtual destructor.</p>
<p>The <a class="el" href="classqglviewer_1_1Camera.html#ad367db656b03fe0bc87b021801d66b75">frame()</a> is deleted, but the different <a class="el" href="classqglviewer_1_1Camera.html#abfbef567a6bbb9163b31c6f46238e4de">keyFrameInterpolator()</a> are <em>not</em> deleted (in case they are shared). </p>

</div>
</div>
<a class="anchor" id="a43d24da01076c4cea5f3dbde85e8482c"></a><!-- doxytag: member="qglviewer::Camera::Camera" ref="a43d24da01076c4cea5f3dbde85e8482c" args="(const Camera &amp;camera)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Camera </td>
          <td>(</td>
          <td class="paramtype">const Camera &amp;&nbsp;</td>
          <td class="paramname"> <em>camera</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy constructor. Performs a deep copy using <a class="el" href="classqglviewer_1_1Camera.html#a0f87e84ad3356493738d4fc8331c7362">operator=()</a>. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a804ee001a41c3ddc33948447fc555cec"></a><!-- doxytag: member="qglviewer::Camera::addKeyFrameToPath" ref="a804ee001a41c3ddc33948447fc555cec" args="(int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void addKeyFrameToPath </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds the current Camera <a class="el" href="classqglviewer_1_1Camera.html#abc38a05a597e07c9ff525122682adc50">position()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a691af39b54669fad8b4e73599de22094">orientation()</a> as a keyFrame to the path number <code>i</code>.</p>
<p>This method can also be used if you simply want to save a Camera point of view (a path made of a single keyFrame). Use <a class="el" href="classqglviewer_1_1Camera.html#a4eb47bb1cf02f806f1f355f63b445818">playPath()</a> to make the Camera play the keyFrame path (resp. restore the point of view). Use <a class="el" href="classqglviewer_1_1Camera.html#a8a75fa050d365ba249e8dcd439670aac">deletePath()</a> to clear the path.</p>
<p>The default keyboard shortcut for this method is Alt+F[1-12]. Set <a class="el" href="classQGLViewer.html#adfe21e109b45f8c79f2c360bf35fb835">QGLViewer::pathKey()</a> and <a class="el" href="classQGLViewer.html#a7c91f5b77f92266cff3fe4ef99847b93">QGLViewer::addKeyFrameKeyboardModifiers()</a>.</p>
<p>If you use directly this method and the keyFrameInterpolator(i) does not exist, a new one is created. Its <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html#ab55c2a4f1732b90057fae4b6037399de">KeyFrameInterpolator::interpolated()</a> signal should then be connected to the <a class="el" href="classQGLViewer.html#ae12b7378efbffabc24a133ca1deb19ae">QGLViewer::updateGL()</a> slot (see <a class="el" href="classqglviewer_1_1Camera.html#a049b63c8c9ef48e24446ce44a3bd32b5">setKeyFrameInterpolator()</a>). </p>

</div>
</div>
<a class="anchor" id="a915589f4d93e15d110444ed9b3464fa1"></a><!-- doxytag: member="qglviewer::Camera::aspectRatio" ref="a915589f4d93e15d110444ed9b3464fa1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float aspectRatio </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the Camera aspect ratio defined by <a class="el" href="classqglviewer_1_1Camera.html#a80386c5943505b915246563262825d8e">screenWidth()</a> / <a class="el" href="classqglviewer_1_1Camera.html#a9fb925ffbf82e93898ae6db366a8d794">screenHeight()</a>.</p>
<p>When the Camera is attached to a <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a>, these values and hence the <a class="el" href="classqglviewer_1_1Camera.html#a915589f4d93e15d110444ed9b3464fa1">aspectRatio()</a> are automatically fitted to the viewer's window aspect ratio using <a class="el" href="classqglviewer_1_1Camera.html#a504c573cdd26be8b717a6da9fdb41812">setScreenWidthAndHeight()</a>. </p>

</div>
</div>
<a class="anchor" id="a5dd8eca926558c252d7552d85079880a"></a><!-- doxytag: member="qglviewer::Camera::cameraCoordinatesOf" ref="a5dd8eca926558c252d7552d85079880a" args="(const Vec &amp;src) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqglviewer_1_1Vec.html">Vec</a> cameraCoordinatesOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the Camera frame coordinates of a point <code>src</code> defined in world coordinates.</p>
<p><a class="el" href="classqglviewer_1_1Camera.html#a123ad9bda6d715b5370650c2514896ab">worldCoordinatesOf()</a> performs the inverse transformation.</p>
<p>Note that the point coordinates are simply converted in a different coordinate system. They are not projected on screen. Use <a class="el" href="classqglviewer_1_1Camera.html#ac4dc649d17bd2ae8664a7f4fdd50360f">projectedCoordinatesOf()</a> for that. </p>

</div>
</div>
<a class="anchor" id="abf37eb8d64d09f93771b42b95cad00f6"></a><!-- doxytag: member="qglviewer::Camera::centerScene" ref="abf37eb8d64d09f93771b42b95cad00f6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void centerScene </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Moves the Camera so that its <a class="el" href="classqglviewer_1_1Camera.html#a87bccbfd40649310f3da369af02d50b1">sceneCenter()</a> is projected on the center of the window. The <a class="el" href="classqglviewer_1_1Camera.html#a691af39b54669fad8b4e73599de22094">orientation()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a89f1a2e62f7edf51de2d1c077ea5d330">fieldOfView()</a> are unchanged.</p>
<p>Simply projects the current position on a line passing through <a class="el" href="classqglviewer_1_1Camera.html#a87bccbfd40649310f3da369af02d50b1">sceneCenter()</a>. See also <a class="el" href="classqglviewer_1_1Camera.html#ada8dd7d2346ebf46ed1f9822a8418df2">showEntireScene()</a>. </p>

</div>
</div>
<a class="anchor" id="a0dad4baab6008e5a94e8a2fa83ec0f05"></a><!-- doxytag: member="qglviewer::Camera::computeModelViewMatrix" ref="a0dad4baab6008e5a94e8a2fa83ec0f05" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void computeModelViewMatrix </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the modelView matrix associated with the Camera's <a class="el" href="classqglviewer_1_1Camera.html#abc38a05a597e07c9ff525122682adc50">position()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a691af39b54669fad8b4e73599de22094">orientation()</a>.</p>
<p>This matrix converts from the world coordinates system to the Camera coordinates system, so that coordinates can then be projected on screen using the projection matrix (see <a class="el" href="classqglviewer_1_1Camera.html#ae51b6c486fe6448453369174bbea8055">computeProjectionMatrix()</a>).</p>
<p>Use <a class="el" href="classqglviewer_1_1Camera.html#aa1d631d6e368a7aa14656b7511787786">getModelViewMatrix()</a> to retrieve this matrix.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>You must call this method if your Camera is not associated with a <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a> and is used for offscreen computations (using (un)<a class="el" href="classqglviewer_1_1Camera.html#ac4dc649d17bd2ae8664a7f4fdd50360f">projectedCoordinatesOf()</a> for instance). <a class="el" href="classqglviewer_1_1Camera.html#a81053f822008b76bff7b1a41dceedf53">loadModelViewMatrix()</a> does it otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae51b6c486fe6448453369174bbea8055"></a><!-- doxytag: member="qglviewer::Camera::computeProjectionMatrix" ref="ae51b6c486fe6448453369174bbea8055" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void computeProjectionMatrix </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the projection matrix associated with the Camera.</p>
<p>If <a class="el" href="classqglviewer_1_1Camera.html#afbd0fa31db28593e9669c3c56711c0a7">type()</a> is <a class="el" href="classqglviewer_1_1Camera.html#a1d1cfd8ffb84e947f82999c682b666a7a2c5d7801888c03752f28943ac85d805f">Camera::PERSPECTIVE</a>, defines a <code>GL_PROJECTION</code> matrix similar to what would <code>gluPerspective()</code> do using the <a class="el" href="classqglviewer_1_1Camera.html#a89f1a2e62f7edf51de2d1c077ea5d330">fieldOfView()</a>, window <a class="el" href="classqglviewer_1_1Camera.html#a915589f4d93e15d110444ed9b3464fa1">aspectRatio()</a>, <a class="el" href="classqglviewer_1_1Camera.html#a419a57556a6681c3a0489c847d687ea5">zNear()</a> and <a class="el" href="classqglviewer_1_1Camera.html#aa7461df81c1ea0384d4c64723eb7b949">zFar()</a> parameters.</p>
<p>If <a class="el" href="classqglviewer_1_1Camera.html#afbd0fa31db28593e9669c3c56711c0a7">type()</a> is <a class="el" href="classqglviewer_1_1Camera.html#a1d1cfd8ffb84e947f82999c682b666a7ae7bf29f117630a30ba5ffc75b33ac624">Camera::ORTHOGRAPHIC</a>, the projection matrix is as what <code>glOrtho()</code> would do. Frustum's width and height are set using <a class="el" href="classqglviewer_1_1Camera.html#affe84ed52b08d5d1d3dfdb87fe9242fa">getOrthoWidthHeight()</a>.</p>
<p>Both types use <a class="el" href="classqglviewer_1_1Camera.html#a419a57556a6681c3a0489c847d687ea5">zNear()</a> and <a class="el" href="classqglviewer_1_1Camera.html#aa7461df81c1ea0384d4c64723eb7b949">zFar()</a> to place clipping planes. These values are determined from <a class="el" href="classqglviewer_1_1Camera.html#a58c17044cc4a601c6b446bf5e83513f9">sceneRadius()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a87bccbfd40649310f3da369af02d50b1">sceneCenter()</a> so that they best fit the scene size.</p>
<p>Use <a class="el" href="classqglviewer_1_1Camera.html#a97ff5cf330a6c24d6d49308aedd638bc">getProjectionMatrix()</a> to retrieve this matrix. Overload <a class="el" href="classqglviewer_1_1Camera.html#a98a0679a22f005bbd8cc19756507cc9a">loadProjectionMatrix()</a> if you want your Camera to use an exotic projection matrix.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>You must call this method if your Camera is not associated with a <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a> and is used for offscreen computations (using (un)<a class="el" href="classqglviewer_1_1Camera.html#ac4dc649d17bd2ae8664a7f4fdd50360f">projectedCoordinatesOf()</a> for instance). <a class="el" href="classqglviewer_1_1Camera.html#a98a0679a22f005bbd8cc19756507cc9a">loadProjectionMatrix()</a> does it otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a706d401cffa41e0e30864e59007f005f"></a><!-- doxytag: member="qglviewer::Camera::convertClickToLine" ref="a706d401cffa41e0e30864e59007f005f" args="(const QPoint &amp;pixel, Vec &amp;orig, Vec &amp;dir) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void convertClickToLine </td>
          <td>(</td>
          <td class="paramtype">const QPoint &amp;&nbsp;</td>
          <td class="paramname"> <em>pixel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>orig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dir</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gives the coefficients of a 3D half-line passing through the Camera eye and pixel (x,y).</p>
<p>The origin of the half line (eye position) is stored in <code>orig</code>, while <code>dir</code> contains the properly oriented and normalized direction of the half line.</p>
<p><code>x</code> and <code>y</code> are expressed in Qt format (origin in the upper left corner). Use <a class="el" href="classqglviewer_1_1Camera.html#a9fb925ffbf82e93898ae6db366a8d794">screenHeight()</a> - y to convert to OpenGL units.</p>
<p>This method is useful for analytical intersection in a selection method.</p>
<p>See the <a href="../examples/select.html">select example</a> for an illustration. </p>

</div>
</div>
<a class="anchor" id="a8a75fa050d365ba249e8dcd439670aac"></a><!-- doxytag: member="qglviewer::Camera::deletePath" ref="a8a75fa050d365ba249e8dcd439670aac" args="(int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void deletePath </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deletes the <a class="el" href="classqglviewer_1_1Camera.html#abfbef567a6bbb9163b31c6f46238e4de">keyFrameInterpolator()</a> of index <code>i</code>.</p>
<p>Disconnect the <a class="el" href="classqglviewer_1_1Camera.html#abfbef567a6bbb9163b31c6f46238e4de">keyFrameInterpolator()</a> <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html#ab55c2a4f1732b90057fae4b6037399de">KeyFrameInterpolator::interpolated()</a> signal before deleting the <a class="el" href="classqglviewer_1_1Camera.html#abfbef567a6bbb9163b31c6f46238e4de">keyFrameInterpolator()</a> if needed: </p>
<div class="fragment"><pre class="fragment">disconnect(camera()-&gt;<a class="code" href="classqglviewer_1_1Camera.html#abfbef567a6bbb9163b31c6f46238e4de">keyFrameInterpolator</a>(i), SIGNAL(interpolated()), <span class="keyword">this</span>, SLOT(updateGL()));
camera()-&gt;deletePath(i);
</pre></div> 
</div>
</div>
<a class="anchor" id="a253932bd8634348f9c189ab4c9b280b5"></a><!-- doxytag: member="qglviewer::Camera::distanceToSceneCenter" ref="a253932bd8634348f9c189ab4c9b280b5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float distanceToSceneCenter </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the distance from the Camera center to <a class="el" href="classqglviewer_1_1Camera.html#a87bccbfd40649310f3da369af02d50b1">sceneCenter()</a>, projected along the Camera Z axis. Used by <a class="el" href="classqglviewer_1_1Camera.html#a419a57556a6681c3a0489c847d687ea5">zNear()</a> and <a class="el" href="classqglviewer_1_1Camera.html#aa7461df81c1ea0384d4c64723eb7b949">zFar()</a> to optimize the Z range. </p>

</div>
</div>
<a class="anchor" id="a48e0e2dd26cd96418c8b889ceabe80f6"></a><!-- doxytag: member="qglviewer::Camera::domElement" ref="a48e0e2dd26cd96418c8b889ceabe80f6" args="(const QString &amp;name, QDomDocument &amp;document) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDomElement domElement </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QDomDocument &amp;&nbsp;</td>
          <td class="paramname"> <em>document</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns an XML <code>QDomElement</code> that represents the Camera.</p>
<p><code>name</code> is the name of the QDomElement tag. <code>doc</code> is the <code>QDomDocument</code> factory used to create QDomElement.</p>
<p>Concatenates the Camera parameters, the <a class="el" href="classqglviewer_1_1ManipulatedCameraFrame.html#a48e0e2dd26cd96418c8b889ceabe80f6">ManipulatedCameraFrame::domElement()</a> and the paths' <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html#a48e0e2dd26cd96418c8b889ceabe80f6">KeyFrameInterpolator::domElement()</a>.</p>
<p>Use <a class="el" href="classqglviewer_1_1Camera.html#acd13d2ddeca530cb9f26ead47f7d25d3">initFromDOMElement()</a> to restore the Camera state from the resulting <code>QDomElement</code>.</p>
<p>If you want to save the Camera state in a file, use: </p>
<div class="fragment"><pre class="fragment">  QDomDocument document(<span class="stringliteral">&quot;myCamera&quot;</span>);
  doc.appendChild( myCamera-&gt;domElement(<span class="stringliteral">&quot;Camera&quot;</span>, document) );

  QFile f(<span class="stringliteral">&quot;myCamera.xml&quot;</span>);
  <span class="keywordflow">if</span> (f.open(IO_WriteOnly))
    {
      QTextStream out(&amp;f);
      document.save(out, 2);
    }
</pre></div><p>Note that the <a class="el" href="classQGLViewer.html#a27a9e97573822d296b48e1c408b74042">QGLViewer::camera()</a> is automatically saved by <a class="el" href="classQGLViewer.html#aaec9168a5f41b3b7fa4211523535ceaa">QGLViewer::saveStateToFile()</a> when a <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a> is closed. Use <a class="el" href="classQGLViewer.html#a212f6b7b669463c2151688f629d72a81">QGLViewer::restoreStateFromFile()</a> to restore it back. </p>

</div>
</div>
<a class="anchor" id="a1636e20e6910ded1c9a5860ba91f397e"></a><!-- doxytag: member="qglviewer::Camera::draw" ref="a1636e20e6910ded1c9a5860ba91f397e" args="(bool drawFarPlane=true, float scale=1.0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void draw </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>drawFarPlane</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>scale</em> = <code>1.0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draws a representation of the Camera in the 3D world.</p>
<p>The near and far planes are drawn as quads, the frustum is drawn using lines and the camera up vector is represented by an arrow to disambiguate the drawing. See the <a href="../examples/standardCamera.html">standardCamera example</a> for an illustration.</p>
<p>Note that the current <code>glColor</code> and <code>glPolygonMode</code> are used to draw the near and far planes. See the <a href="../examples/frustumCulling.html">frustumCulling example</a> for an example of semi-transparent plane drawing. Similarly, the current <code>glLineWidth</code> and <code>glColor</code> is used to draw the frustum outline.</p>
<p>When <code>drawFarPlane</code> is <code>false</code>, only the near plane is drawn. <code>scale</code> can be used to scale the drawing: a value of 1.0 (default) will draw the Camera's frustum at its actual size.</p>
<p>This method assumes that the <code>glMatrixMode</code> is <code>GL_MODELVIEW</code> and that the current ModelView matrix corresponds to the world coordinate system (as it is at the beginning of <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">QGLViewer::draw()</a>). The Camera is then correctly positioned and orientated.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The drawing of a QGLViewer's own <a class="el" href="classQGLViewer.html#a27a9e97573822d296b48e1c408b74042">QGLViewer::camera()</a> should not be visible, but may create artefacts due to numerical imprecisions. </dd></dl>

</div>
</div>
<a class="anchor" id="aeea4caff561e6b1d8fe4b3d8efe4ae87"></a><!-- doxytag: member="qglviewer::Camera::drawAllPaths" ref="aeea4caff561e6b1d8fe4b3d8efe4ae87" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drawAllPaths </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draws all the Camera paths defined by the <a class="el" href="classqglviewer_1_1Camera.html#abfbef567a6bbb9163b31c6f46238e4de">keyFrameInterpolator()</a>.</p>
<p>Simply calls <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html#aca0ce46b39ad4093450019d77fd247f2">KeyFrameInterpolator::drawPath()</a> for all the defined paths. The path color is the current <code>glColor()</code>.</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>The OpenGL state is modified by this method: see <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html#aca0ce46b39ad4093450019d77fd247f2">KeyFrameInterpolator::drawPath()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a89f1a2e62f7edf51de2d1c077ea5d330"></a><!-- doxytag: member="qglviewer::Camera::fieldOfView" ref="a89f1a2e62f7edf51de2d1c077ea5d330" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float fieldOfView </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the vertical field of view of the Camera (in radians).</p>
<p>Value is set using <a class="el" href="classqglviewer_1_1Camera.html#a524f0183a127bb004defe3c2f7614e4c">setFieldOfView()</a>. Default value is pi/4 radians. This value is meaningless if the Camera <a class="el" href="classqglviewer_1_1Camera.html#afbd0fa31db28593e9669c3c56711c0a7">type()</a> is <a class="el" href="classqglviewer_1_1Camera.html#a1d1cfd8ffb84e947f82999c682b666a7ae7bf29f117630a30ba5ffc75b33ac624">Camera::ORTHOGRAPHIC</a>.</p>
<p>The field of view corresponds the one used in <code>gluPerspective</code> (see manual). It sets the Y (vertical) aperture of the Camera. The X (horizontal) angle is inferred from the window aspect ratio (see <a class="el" href="classqglviewer_1_1Camera.html#a915589f4d93e15d110444ed9b3464fa1">aspectRatio()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a957cf1049788f7aba3dd16f20f565960">horizontalFieldOfView()</a>).</p>
<p>Use <a class="el" href="classqglviewer_1_1Camera.html#a3394c425f95c5649b1e2e532dbd97fa7">setFOVToFitScene()</a> to adapt the <a class="el" href="classqglviewer_1_1Camera.html#a89f1a2e62f7edf51de2d1c077ea5d330">fieldOfView()</a> to a given scene. </p>

</div>
</div>
<a class="anchor" id="a65a284702aab36f853d59ce6c7a082b9"></a><!-- doxytag: member="qglviewer::Camera::fitBoundingBox" ref="a65a284702aab36f853d59ce6c7a082b9" args="(const Vec &amp;min, const Vec &amp;max)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fitBoundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>max</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Moves the Camera so that the (world axis aligned) bounding box (<code>min</code>, <code>max</code>) is entirely visible, using <a class="el" href="classqglviewer_1_1Camera.html#a424fbe98af0ca295c692d8d4ae73ceec">fitSphere()</a>. </p>

</div>
</div>
<a class="anchor" id="ac49a71148d1d501310026f6f6f76d471"></a><!-- doxytag: member="qglviewer::Camera::fitScreenRegion" ref="ac49a71148d1d501310026f6f6f76d471" args="(const QRect &amp;rectangle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fitScreenRegion </td>
          <td>(</td>
          <td class="paramtype">const QRect &amp;&nbsp;</td>
          <td class="paramname"> <em>rectangle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Moves the Camera so that the rectangular screen region defined by <code>rectangle</code> (pixel units, with origin in the upper left corner) fits the screen.</p>
<p>The Camera is translated (its <a class="el" href="classqglviewer_1_1Camera.html#a691af39b54669fad8b4e73599de22094">orientation()</a> is unchanged) so that <code>rectangle</code> is entirely visible. Since the pixel coordinates only define a <em>frustum</em> in 3D, it's the intersection of this frustum with a plane (orthogonal to the <a class="el" href="classqglviewer_1_1Camera.html#aac10e453c166209b4e6c14c0266651c7">viewDirection()</a> and passing through the <a class="el" href="classqglviewer_1_1Camera.html#a87bccbfd40649310f3da369af02d50b1">sceneCenter()</a>) that is used to define the 3D rectangle that is eventually fitted. </p>

</div>
</div>
<a class="anchor" id="a424fbe98af0ca295c692d8d4ae73ceec"></a><!-- doxytag: member="qglviewer::Camera::fitSphere" ref="a424fbe98af0ca295c692d8d4ae73ceec" args="(const Vec &amp;center, float radius)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fitSphere </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>radius</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Moves the Camera so that the sphere defined by (<code>center</code>, <code>radius</code>) is visible and fits the window.</p>
<p>The Camera is simply translated along its <a class="el" href="classqglviewer_1_1Camera.html#aac10e453c166209b4e6c14c0266651c7">viewDirection()</a> so that the sphere fits the screen. Its <a class="el" href="classqglviewer_1_1Camera.html#a691af39b54669fad8b4e73599de22094">orientation()</a> and its <a class="el" href="classqglviewer_1_1Camera.html#a89f1a2e62f7edf51de2d1c077ea5d330">fieldOfView()</a> are unchanged.</p>
<p>You should therefore orientate the Camera before you call this method. See <a class="el" href="classqglviewer_1_1Camera.html#aafe147ffa75738c296c729d9b5026446">lookAt()</a>, <a class="el" href="classqglviewer_1_1Camera.html#a3862c502f5afc626af2ff582390bc868">setOrientation()</a> and <a class="el" href="classqglviewer_1_1Camera.html#ab442b71a46297223ae12b163653eeb7e">setUpVector()</a>. </p>

</div>
</div>
<a class="anchor" id="ac1758b72dab0895b9340fa833e62b802"></a><!-- doxytag: member="qglviewer::Camera::flySpeed" ref="ac1758b72dab0895b9340fa833e62b802" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float flySpeed </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the fly speed of the Camera.</p>
<p>Simply returns <a class="el" href="classqglviewer_1_1Camera.html#ad367db656b03fe0bc87b021801d66b75">frame()</a>-&gt;<a class="el" href="classqglviewer_1_1Camera.html#ac1758b72dab0895b9340fa833e62b802">flySpeed()</a>. See the <a class="el" href="classqglviewer_1_1ManipulatedCameraFrame.html#ac1758b72dab0895b9340fa833e62b802">ManipulatedCameraFrame::flySpeed()</a> documentation. This value is only meaningful when the MouseAction bindings is <a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875a99906f0ddded6cfdab57271cd33e308c">MOVE_FORWARD</a> or <a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875ab3313fc5887b62fd14b36f1d67903e08">MOVE_BACKWARD</a>.</p>
<p>Set to 0.5% of the <a class="el" href="classqglviewer_1_1Camera.html#a58c17044cc4a601c6b446bf5e83513f9">sceneRadius()</a> by <a class="el" href="classqglviewer_1_1Camera.html#a33c70507fea15c3ea49a561b743ed822">setSceneRadius()</a>. See also <a class="el" href="classqglviewer_1_1Camera.html#a02765efeaae1ef24f9d899f0d1d9ca09">setFlySpeed()</a>. </p>

</div>
</div>
<a class="anchor" id="af201ce62f669c8944a276a2615951379"></a><!-- doxytag: member="qglviewer::Camera::focusDistance" ref="af201ce62f669c8944a276a2615951379" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float focusDistance </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the focus distance used by stereo display, expressed in OpenGL units.</p>
<p>This is the distance in the virtual world between the Camera and the plane where the horizontal stereo parallax is null (the stereo left and right images are superimposed).</p>
<p>This distance is the virtual world equivalent of the real-world <a class="el" href="classqglviewer_1_1Camera.html#a2cbb7d182c56732a6129936c5dd19d64">physicalDistanceToScreen()</a>.</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>This value is modified by <a class="el" href="classQGLViewer.html#aef99f105486d457f0199fcc35181fa83">QGLViewer::setSceneRadius()</a>, <a class="el" href="classqglviewer_1_1Camera.html#a33c70507fea15c3ea49a561b743ed822">setSceneRadius()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a524f0183a127bb004defe3c2f7614e4c">setFieldOfView()</a>. When one of these values is modified, <a class="el" href="classqglviewer_1_1Camera.html#af201ce62f669c8944a276a2615951379">focusDistance()</a> is set to <a class="el" href="classqglviewer_1_1Camera.html#a58c17044cc4a601c6b446bf5e83513f9">sceneRadius()</a> / tan(<a class="el" href="classqglviewer_1_1Camera.html#a89f1a2e62f7edf51de2d1c077ea5d330">fieldOfView()</a>/2), which provides good results. </dd></dl>

</div>
</div>
<a class="anchor" id="ad367db656b03fe0bc87b021801d66b75"></a><!-- doxytag: member="qglviewer::Camera::frame" ref="ad367db656b03fe0bc87b021801d66b75" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqglviewer_1_1ManipulatedCameraFrame.html">ManipulatedCameraFrame</a>* frame </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the <a class="el" href="classqglviewer_1_1ManipulatedCameraFrame.html" title="The ManipulatedCameraFrame class represents a ManipulatedFrame with Camera specific...">ManipulatedCameraFrame</a> attached to the Camera.</p>
<p>This <a class="el" href="classqglviewer_1_1ManipulatedCameraFrame.html" title="The ManipulatedCameraFrame class represents a ManipulatedFrame with Camera specific...">ManipulatedCameraFrame</a> defines its <a class="el" href="classqglviewer_1_1Camera.html#abc38a05a597e07c9ff525122682adc50">position()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a691af39b54669fad8b4e73599de22094">orientation()</a> and can translate mouse events into Camera displacement. Set using <a class="el" href="classqglviewer_1_1Camera.html#a809bad30c861f4f6f74228fb59340f90">setFrame()</a>. </p>

</div>
</div>
<a class="anchor" id="abadd060aa34d51a940575b58d256dca4"></a><!-- doxytag: member="qglviewer::Camera::getCameraCoordinatesOf" ref="abadd060aa34d51a940575b58d256dca4" args="(const float src[3], float res[3]) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getCameraCoordinatesOf </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>src</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>res</em>[3]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Same as <a class="el" href="classqglviewer_1_1Camera.html#a5dd8eca926558c252d7552d85079880a">cameraCoordinatesOf()</a>, but with <code>float</code>[3] parameters (<code>src</code> and <code>res</code> may be identical pointers). </p>

</div>
</div>
<a class="anchor" id="a1450258d117908a71908a72184136e41"></a><!-- doxytag: member="qglviewer::Camera::getFrustumPlanesCoefficients" ref="a1450258d117908a71908a72184136e41" args="(GLdouble coef[6][4]) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getFrustumPlanesCoefficients </td>
          <td>(</td>
          <td class="paramtype">GLdouble&nbsp;</td>
          <td class="paramname"> <em>coef</em>[6][4]</td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the 6 plane equations of the Camera frustum.</p>
<p>The six 4-component vectors of <code>coef</code> respectively correspond to the left, right, near, far, top and bottom Camera frustum planes. Each vector holds a plane equation of the form: </p>
<div class="fragment"><pre class="fragment">a*x + b*y + c*z + d = 0 
</pre></div><p> where <code>a</code>, <code>b</code>, <code>c</code> and <code>d</code> are the 4 components of each vector, in that order.</p>
<p>See the <a href="../examples/frustumCulling.html">frustumCulling example</a> for an application.</p>
<p>This format is compatible with the <code>glClipPlane()</code> function. One camera frustum plane can hence be applied in an other viewer to visualize the culling results: </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// Retrieve plance equations</span>
 GLdouble coef[6][4];
 mainViewer-&gt;camera()-&gt;getFrustumPlanesCoefficients(coef);

 <span class="comment">// These two additional clipping planes (which must have been enabled)</span>
 <span class="comment">// will reproduce the mainViewer&#39;s near and far clipping.</span>
 glClipPlane(GL_CLIP_PLANE0, coef[2]);
 glClipPlane(GL_CLIP_PLANE1, coef[3]);
</pre></div> 
</div>
</div>
<a class="anchor" id="aa1d631d6e368a7aa14656b7511787786"></a><!-- doxytag: member="qglviewer::Camera::getModelViewMatrix" ref="aa1d631d6e368a7aa14656b7511787786" args="(GLdouble m[16]) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getModelViewMatrix </td>
          <td>(</td>
          <td class="paramtype">GLdouble&nbsp;</td>
          <td class="paramname"> <em>m</em>[16]</td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fills <code>m</code> with the Camera modelView matrix values.</p>
<p>First calls <a class="el" href="classqglviewer_1_1Camera.html#a0dad4baab6008e5a94e8a2fa83ec0f05">computeModelViewMatrix()</a> to define the Camera modelView matrix.</p>
<p>Note that this matrix is usually <em>not</em> the one you would get from a <code>glGetDoublev(GL_MODELVIEW_MATRIX, m)</code>. It actually represents the state of the <code>GL_MODELVIEW</code> after <a class="el" href="classQGLViewer.html#a9c6b3ec107b4f010cf1fcd8c51ca92e4">QGLViewer::preDraw()</a>, at the beginning of <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">QGLViewer::draw()</a>. It converts from the world to the Camera coordinate system. As soon as you modify the <code>GL_MODELVIEW</code> in your <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">QGLViewer::draw()</a> method, the two matrices differ.</p>
<p>The result is an OpenGL 4x4 matrix, which is given in <em>column-major</em> order (see <code>glMultMatrix</code> man page for details).</p>
<p>See also <a class="el" href="classqglviewer_1_1Camera.html#a97ff5cf330a6c24d6d49308aedd638bc">getProjectionMatrix()</a> and <a class="el" href="classqglviewer_1_1Camera.html#ab21e4c76205431bdeba645a5f258dce9">setFromModelViewMatrix()</a>. </p>

</div>
</div>
<a class="anchor" id="adeb5e39686b9fcb3db090dff84c13be4"></a><!-- doxytag: member="qglviewer::Camera::getModelViewProjectionMatrix" ref="adeb5e39686b9fcb3db090dff84c13be4" args="(GLdouble m[16]) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getModelViewProjectionMatrix </td>
          <td>(</td>
          <td class="paramtype">GLdouble&nbsp;</td>
          <td class="paramname"> <em>m</em>[16]</td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fills <code>m</code> with the product of the ModelView and Projection matrices.</p>
<p>Calls <a class="el" href="classqglviewer_1_1Camera.html#aa1d631d6e368a7aa14656b7511787786">getModelViewMatrix()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a97ff5cf330a6c24d6d49308aedd638bc">getProjectionMatrix()</a> and then fills <code>m</code> with the product of these two matrices. </p>

</div>
</div>
<a class="anchor" id="affe84ed52b08d5d1d3dfdb87fe9242fa"></a><!-- doxytag: member="qglviewer::Camera::getOrthoWidthHeight" ref="affe84ed52b08d5d1d3dfdb87fe9242fa" args="(GLdouble &amp;halfWidth, GLdouble &amp;halfHeight) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getOrthoWidthHeight </td>
          <td>(</td>
          <td class="paramtype">GLdouble &amp;&nbsp;</td>
          <td class="paramname"> <em>halfWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLdouble &amp;&nbsp;</td>
          <td class="paramname"> <em>halfHeight</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the <code>halfWidth</code> and <code>halfHeight</code> of the Camera orthographic frustum.</p>
<p>These values are only valid and used when the Camera is of <a class="el" href="classqglviewer_1_1Camera.html#afbd0fa31db28593e9669c3c56711c0a7">type()</a> <a class="el" href="classqglviewer_1_1Camera.html#a1d1cfd8ffb84e947f82999c682b666a7ae7bf29f117630a30ba5ffc75b33ac624">Camera::ORTHOGRAPHIC</a>. They are expressed in OpenGL units and are used by <a class="el" href="classqglviewer_1_1Camera.html#a98a0679a22f005bbd8cc19756507cc9a">loadProjectionMatrix()</a> to define the projection matrix using: </p>
<div class="fragment"><pre class="fragment"> glOrtho( -halfWidth, halfWidth, -halfHeight, halfHeight, <a class="code" href="classqglviewer_1_1Camera.html#a419a57556a6681c3a0489c847d687ea5">zNear</a>(), <a class="code" href="classqglviewer_1_1Camera.html#aa7461df81c1ea0384d4c64723eb7b949">zFar</a>() )
</pre></div><p>These values are proportional to the Camera (z projected) distance to the <a class="el" href="classqglviewer_1_1Camera.html#afd168442e2a05bd41881936fb722b5fe">revolveAroundPoint()</a>. When zooming on the object, the Camera is translated forward <em>and</em> its frustum is narrowed, making the object appear bigger on screen, as intuitively expected.</p>
<p>Overload this method to change this behavior if desired, as is done in the <a href="../examples/standardCamera.html">standardCamera example</a>. </p>

</div>
</div>
<a class="anchor" id="ae167e3b955401e11bbbf0fc25f52e3ee"></a><!-- doxytag: member="qglviewer::Camera::getProjectedCoordinatesOf" ref="ae167e3b955401e11bbbf0fc25f52e3ee" args="(const float src[3], float res[3], const Frame *frame=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getProjectedCoordinatesOf </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>src</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>res</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classqglviewer_1_1Frame.html">Frame</a> *&nbsp;</td>
          <td class="paramname"> <em>frame</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Same as <a class="el" href="classqglviewer_1_1Camera.html#ac4dc649d17bd2ae8664a7f4fdd50360f">projectedCoordinatesOf()</a>, but with <code>float</code> parameters (<code>src</code> and <code>res</code> can be identical pointers). </p>

</div>
</div>
<a class="anchor" id="a97ff5cf330a6c24d6d49308aedd638bc"></a><!-- doxytag: member="qglviewer::Camera::getProjectionMatrix" ref="a97ff5cf330a6c24d6d49308aedd638bc" args="(GLdouble m[16]) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getProjectionMatrix </td>
          <td>(</td>
          <td class="paramtype">GLdouble&nbsp;</td>
          <td class="paramname"> <em>m</em>[16]</td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fills <code>m</code> with the Camera projection matrix values.</p>
<p>Calls <a class="el" href="classqglviewer_1_1Camera.html#ae51b6c486fe6448453369174bbea8055">computeProjectionMatrix()</a> to define the Camera projection matrix.</p>
<p>This matrix only reflects the Camera's internal parameters and it may differ from the <code>GL_PROJECTION</code> matrix retrieved using <code>glGetDoublev(GL_PROJECTION_MATRIX, m)</code>. It actually represents the state of the <code>GL_PROJECTION</code> after <a class="el" href="classQGLViewer.html#a9c6b3ec107b4f010cf1fcd8c51ca92e4">QGLViewer::preDraw()</a>, at the beginning of <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">QGLViewer::draw()</a>. If you modified the <code>GL_PROJECTION</code> matrix (for instance using <a class="el" href="classQGLViewer.html#a5825ac26bdef13ae5ddd021e318aaf15">QGLViewer::startScreenCoordinatesSystem()</a>), the two results differ.</p>
<p>The result is an OpenGL 4x4 matrix, which is given in <em>column-major</em> order (see <code>glMultMatrix</code> man page for details).</p>
<p>See also <a class="el" href="classqglviewer_1_1Camera.html#aa1d631d6e368a7aa14656b7511787786">getModelViewMatrix()</a> and <a class="el" href="classqglviewer_1_1Camera.html#ac49280735bce44665a4eabb166f10fcd">setFromProjectionMatrix()</a>. </p>

</div>
</div>
<a class="anchor" id="a222deedc6fa32ab78d0a338eaa312f1f"></a><!-- doxytag: member="qglviewer::Camera::getUnprojectedCoordinatesOf" ref="a222deedc6fa32ab78d0a338eaa312f1f" args="(const float src[3], float res[3], const Frame *frame=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getUnprojectedCoordinatesOf </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>src</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>res</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classqglviewer_1_1Frame.html">Frame</a> *&nbsp;</td>
          <td class="paramname"> <em>frame</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Same as <a class="el" href="classqglviewer_1_1Camera.html#a42577d3077e22b4726d78b3db3bba50d">unprojectedCoordinatesOf()</a>, but with <code>float</code> parameters (<code>src</code> and <code>res</code> can be identical pointers). </p>

</div>
</div>
<a class="anchor" id="a5034f21055f864c1ade7d86fec209348"></a><!-- doxytag: member="qglviewer::Camera::getViewport" ref="a5034f21055f864c1ade7d86fec209348" args="(GLint viewport[4]) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getViewport </td>
          <td>(</td>
          <td class="paramtype">GLint&nbsp;</td>
          <td class="paramname"> <em>viewport</em>[4]</td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fills <code>viewport</code> with the Camera OpenGL viewport.</p>
<p>This method is mainly used in conjunction with <code>gluProject</code>, which requires such a viewport. Returned values are (0, <a class="el" href="classqglviewer_1_1Camera.html#a9fb925ffbf82e93898ae6db366a8d794">screenHeight()</a>, <a class="el" href="classqglviewer_1_1Camera.html#a80386c5943505b915246563262825d8e">screenWidth()</a>, - <a class="el" href="classqglviewer_1_1Camera.html#a9fb925ffbf82e93898ae6db366a8d794">screenHeight()</a>), so that the origin is located in the <em>upper</em> left corner of the window (Qt style coordinate system). </p>

</div>
</div>
<a class="anchor" id="ae1b0a45b7cd3a071c4ef88ed608511fd"></a><!-- doxytag: member="qglviewer::Camera::getWorldCoordinatesOf" ref="ae1b0a45b7cd3a071c4ef88ed608511fd" args="(const float src[3], float res[3]) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getWorldCoordinatesOf </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>src</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>res</em>[3]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Same as <a class="el" href="classqglviewer_1_1Camera.html#a123ad9bda6d715b5370650c2514896ab">worldCoordinatesOf()</a>, but with <code>float</code>[3] parameters (<code>src</code> and <code>res</code> may be identical pointers). </p>

</div>
</div>
<a class="anchor" id="a957cf1049788f7aba3dd16f20f565960"></a><!-- doxytag: member="qglviewer::Camera::horizontalFieldOfView" ref="a957cf1049788f7aba3dd16f20f565960" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float horizontalFieldOfView </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the horizontal field of view of the Camera (in radians).</p>
<p>Value is set using <a class="el" href="classqglviewer_1_1Camera.html#a017ace2ed5f67b6aeaef5c9a47b5f014">setHorizontalFieldOfView()</a> or <a class="el" href="classqglviewer_1_1Camera.html#a524f0183a127bb004defe3c2f7614e4c">setFieldOfView()</a>. These values are always linked by: </p>
<div class="fragment"><pre class="fragment">    <a class="code" href="classqglviewer_1_1Camera.html#a957cf1049788f7aba3dd16f20f565960">horizontalFieldOfView</a>() = 2.0 * atan ( tan(<a class="code" href="classqglviewer_1_1Camera.html#a89f1a2e62f7edf51de2d1c077ea5d330">fieldOfView</a>()/2.0) * <a class="code" href="classqglviewer_1_1Camera.html#a915589f4d93e15d110444ed9b3464fa1">aspectRatio</a>() ).
</pre></div> 
</div>
</div>
<a class="anchor" id="acd13d2ddeca530cb9f26ead47f7d25d3"></a><!-- doxytag: member="qglviewer::Camera::initFromDOMElement" ref="acd13d2ddeca530cb9f26ead47f7d25d3" args="(const QDomElement &amp;element)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initFromDOMElement </td>
          <td>(</td>
          <td class="paramtype">const QDomElement &amp;&nbsp;</td>
          <td class="paramname"> <em>element</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Restores the Camera state from a <code>QDomElement</code> created by <a class="el" href="classqglviewer_1_1Camera.html#a48e0e2dd26cd96418c8b889ceabe80f6">domElement()</a>.</p>
<p>Use the following code to retrieve a Camera state from a file created using <a class="el" href="classqglviewer_1_1Camera.html#a48e0e2dd26cd96418c8b889ceabe80f6">domElement()</a>: </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// Load DOM from file</span>
 QDomDocument document;
 QFile f(<span class="stringliteral">&quot;myCamera.xml&quot;</span>);
 <span class="keywordflow">if</span> (f.open(IO_ReadOnly))
 {
   document.setContent(&amp;f);
   f.close();
 }

 <span class="comment">// Parse the DOM tree</span>
 QDomElement main = document.documentElement();
 myCamera-&gt;initFromDOMElement(main);
</pre></div><p>The <a class="el" href="classqglviewer_1_1Camera.html#ad367db656b03fe0bc87b021801d66b75">frame()</a> pointer is not modified by this method. The <a class="el" href="classqglviewer_1_1Camera.html#ad367db656b03fe0bc87b021801d66b75">frame()</a> state is however modified.</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>The original <a class="el" href="classqglviewer_1_1Camera.html#abfbef567a6bbb9163b31c6f46238e4de">keyFrameInterpolator()</a> are deleted and should be copied first if they are shared. </dd></dl>

</div>
</div>
<a class="anchor" id="a37dee575e0fdf56909e1779e20383e97"></a><!-- doxytag: member="qglviewer::Camera::interpolateTo" ref="a37dee575e0fdf56909e1779e20383e97" args="(const Frame &amp;fr, float duration)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void interpolateTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqglviewer_1_1Frame.html">Frame</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>duration</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Smoothly interpolates the Camera on a <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html" title="A keyFrame Catmull-Rom Frame interpolator.">KeyFrameInterpolator</a> path so that it goes to <code>fr</code>.</p>
<p><code>fr</code> is expressed in world coordinates. <code>duration</code> tunes the interpolation speed (default is 1 second).</p>
<p>See also <a class="el" href="classqglviewer_1_1Camera.html#a8a6201a1c2deca60a917e5351e549bb0">interpolateToFitScene()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a9e2b0c2d37f9176629d737faf431b51c">interpolateToZoomOnPixel()</a>. </p>

</div>
</div>
<a class="anchor" id="a8a6201a1c2deca60a917e5351e549bb0"></a><!-- doxytag: member="qglviewer::Camera::interpolateToFitScene" ref="a8a6201a1c2deca60a917e5351e549bb0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void interpolateToFitScene </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Interpolates the Camera on a one second <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html" title="A keyFrame Catmull-Rom Frame interpolator.">KeyFrameInterpolator</a> path so that the entire scene fits the screen at the end.</p>
<p>The scene is defined by its <a class="el" href="classqglviewer_1_1Camera.html#a87bccbfd40649310f3da369af02d50b1">sceneCenter()</a> and its <a class="el" href="classqglviewer_1_1Camera.html#a58c17044cc4a601c6b446bf5e83513f9">sceneRadius()</a>. See <a class="el" href="classqglviewer_1_1Camera.html#ada8dd7d2346ebf46ed1f9822a8418df2">showEntireScene()</a>.</p>
<p>The <a class="el" href="classqglviewer_1_1Camera.html#a691af39b54669fad8b4e73599de22094">orientation()</a> of the Camera is not modified. See also <a class="el" href="classqglviewer_1_1Camera.html#a9e2b0c2d37f9176629d737faf431b51c">interpolateToZoomOnPixel()</a>. </p>

</div>
</div>
<a class="anchor" id="a9e2b0c2d37f9176629d737faf431b51c"></a><!-- doxytag: member="qglviewer::Camera::interpolateToZoomOnPixel" ref="a9e2b0c2d37f9176629d737faf431b51c" args="(const QPoint &amp;pixel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void interpolateToZoomOnPixel </td>
          <td>(</td>
          <td class="paramtype">const QPoint &amp;&nbsp;</td>
          <td class="paramname"> <em>pixel</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Makes the Camera smoothly zoom on the <a class="el" href="classqglviewer_1_1Camera.html#a90459767f782c80086ad7cff90a40b5a">pointUnderPixel()</a> <code>pixel</code>.</p>
<p>Nothing happens if no <a class="el" href="classqglviewer_1_1Camera.html#a90459767f782c80086ad7cff90a40b5a">pointUnderPixel()</a> is found. Otherwise a <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html" title="A keyFrame Catmull-Rom Frame interpolator.">KeyFrameInterpolator</a> is created that animates the Camera on a one second path that brings the Camera closer to the point under <code>pixel</code>.</p>
<p>See also <a class="el" href="classqglviewer_1_1Camera.html#a8a6201a1c2deca60a917e5351e549bb0">interpolateToFitScene()</a>. </p>

</div>
</div>
<a class="anchor" id="ad36e74de9c4020f951ea1a04e53a192d"></a><!-- doxytag: member="qglviewer::Camera::IODistance" ref="ad36e74de9c4020f951ea1a04e53a192d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float IODistance </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the user's inter-ocular distance (in meters). Default value is 0.062m, which fits most people.</p>
<p><a class="el" href="classqglviewer_1_1Camera.html#a79dac3c1bcb983c9025710b333f063a3">loadProjectionMatrixStereo()</a> uses this value to define the Camera offset and frustum. See <a class="el" href="classqglviewer_1_1Camera.html#a6cd81fe74a9dfe5c7124d00341ad0234">setIODistance()</a>. </p>

</div>
</div>
<a class="anchor" id="abfbef567a6bbb9163b31c6f46238e4de"></a><!-- doxytag: member="qglviewer::Camera::keyFrameInterpolator" ref="abfbef567a6bbb9163b31c6f46238e4de" args="(int i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html">KeyFrameInterpolator</a> * keyFrameInterpolator </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html" title="A keyFrame Catmull-Rom Frame interpolator.">KeyFrameInterpolator</a> that defines the Camera path number <code>i</code>.</p>
<p>If path <code>i</code> is not defined for this index, the method returns a <code>NULL</code> pointer. </p>

</div>
</div>
<a class="anchor" id="a81053f822008b76bff7b1a41dceedf53"></a><!-- doxytag: member="qglviewer::Camera::loadModelViewMatrix" ref="a81053f822008b76bff7b1a41dceedf53" args="(bool reset=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void loadModelViewMatrix </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>reset</em> = <code>true</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Loads the OpenGL <code>GL_MODELVIEW</code> matrix with the modelView matrix corresponding to the Camera.</p>
<p>Calls <a class="el" href="classqglviewer_1_1Camera.html#a0dad4baab6008e5a94e8a2fa83ec0f05">computeModelViewMatrix()</a> to compute the Camera's modelView matrix.</p>
<p>This method is used by <a class="el" href="classQGLViewer.html#a9c6b3ec107b4f010cf1fcd8c51ca92e4">QGLViewer::preDraw()</a> (called before user's <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">QGLViewer::draw()</a> method) to set the <code>GL_MODELVIEW</code> matrix according to the viewer's <a class="el" href="classQGLViewer.html#a27a9e97573822d296b48e1c408b74042">QGLViewer::camera()</a> <a class="el" href="classqglviewer_1_1Camera.html#abc38a05a597e07c9ff525122682adc50">position()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a691af39b54669fad8b4e73599de22094">orientation()</a>.</p>
<p>As a result, the vertices used in <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">QGLViewer::draw()</a> can be defined in the so called world coordinate system. They are multiplied by this matrix to get converted to the Camera coordinate system, before getting projected using the <code>GL_PROJECTION</code> matrix (see <a class="el" href="classqglviewer_1_1Camera.html#a98a0679a22f005bbd8cc19756507cc9a">loadProjectionMatrix()</a>).</p>
<p>When <code>reset</code> is <code>true</code> (default), the method loads (overwrites) the <code>GL_MODELVIEW</code> matrix. Setting <code>reset</code> to <code>false</code> simply calls <code>glMultMatrixd</code> (might be useful for some applications).</p>
<p>Overload this method or simply call glLoadMatrixd() at the beginning of <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">QGLViewer::draw()</a> if you want your Camera to use an exotic modelView matrix. See also <a class="el" href="classqglviewer_1_1Camera.html#a98a0679a22f005bbd8cc19756507cc9a">loadProjectionMatrix()</a>.</p>
<p><a class="el" href="classqglviewer_1_1Camera.html#aa1d631d6e368a7aa14656b7511787786">getModelViewMatrix()</a> returns the 4x4 modelView matrix.</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>glMatrixMode is set to <code>GL_MODELVIEW</code> </dd>
<dd>
If you use several OpenGL contexts and bypass the Qt main refresh loop, you should call QGLWidget::makeCurrent() before this method in order to activate the right OpenGL context. </dd></dl>

</div>
</div>
<a class="anchor" id="a47c0f19a566d045a2872b44014be8392"></a><!-- doxytag: member="qglviewer::Camera::loadModelViewMatrixStereo" ref="a47c0f19a566d045a2872b44014be8392" args="(bool leftBuffer=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void loadModelViewMatrixStereo </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>leftBuffer</em> = <code>true</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Same as <a class="el" href="classqglviewer_1_1Camera.html#a81053f822008b76bff7b1a41dceedf53">loadModelViewMatrix()</a> but for a stereo setup.</p>
<p>Only the <a class="el" href="classqglviewer_1_1Camera.html#a1d1cfd8ffb84e947f82999c682b666a7a2c5d7801888c03752f28943ac85d805f">Camera::PERSPECTIVE</a> <a class="el" href="classqglviewer_1_1Camera.html#afbd0fa31db28593e9669c3c56711c0a7">type()</a> is supported for stereo mode. See <a class="el" href="classQGLViewer.html#afe362ba5c3851a93f23fb833b2479f08">QGLViewer::setStereoDisplay()</a>.</p>
<p>The modelView matrix is almost identical to the mono-vision one. It is simply translated along its horizontal axis by a value that depends on stereo parameters (see <a class="el" href="classqglviewer_1_1Camera.html#af201ce62f669c8944a276a2615951379">focusDistance()</a>, <a class="el" href="classqglviewer_1_1Camera.html#ad36e74de9c4020f951ea1a04e53a192d">IODistance()</a>, and <a class="el" href="classqglviewer_1_1Camera.html#a8418799b4eeb22cbc1a157d488dcf09c">physicalScreenWidth()</a>).</p>
<p>When <code>leftBuffer</code> is <code>true</code>, computes the modelView matrix associated to the left eye (right eye otherwise).</p>
<p><a class="el" href="classqglviewer_1_1Camera.html#a79dac3c1bcb983c9025710b333f063a3">loadProjectionMatrixStereo()</a> explains how to retrieve to resulting matrix.</p>
<p>See the <a href="../examples/stereoViewer.html">stereoViewer</a> and the <a href="../examples/contribs.html#anaglyph">anaglyph</a> examples for an illustration.</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>glMatrixMode is set to <code>GL_MODELVIEW</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a98a0679a22f005bbd8cc19756507cc9a"></a><!-- doxytag: member="qglviewer::Camera::loadProjectionMatrix" ref="a98a0679a22f005bbd8cc19756507cc9a" args="(bool reset=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void loadProjectionMatrix </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>reset</em> = <code>true</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Loads the OpenGL <code>GL_PROJECTION</code> matrix with the Camera projection matrix.</p>
<p>The Camera projection matrix is computed using <a class="el" href="classqglviewer_1_1Camera.html#ae51b6c486fe6448453369174bbea8055">computeProjectionMatrix()</a>.</p>
<p>When <code>reset</code> is <code>true</code> (default), the method clears the previous projection matrix by calling <code>glLoadIdentity</code> before setting the matrix. Setting <code>reset</code> to <code>false</code> is useful for <code>GL_SELECT</code> mode, to combine the pushed matrix with a picking matrix. See <a class="el" href="classQGLViewer.html#af0a48cc50f194926bad38d4924162116">QGLViewer::beginSelection()</a> for details.</p>
<p>This method is used by <a class="el" href="classQGLViewer.html#a9c6b3ec107b4f010cf1fcd8c51ca92e4">QGLViewer::preDraw()</a> (called before user's <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">QGLViewer::draw()</a> method) to set the <code>GL_PROJECTION</code> matrix according to the viewer's <a class="el" href="classQGLViewer.html#a27a9e97573822d296b48e1c408b74042">QGLViewer::camera()</a> settings.</p>
<p>Use <a class="el" href="classqglviewer_1_1Camera.html#a97ff5cf330a6c24d6d49308aedd638bc">getProjectionMatrix()</a> to retrieve this matrix. Overload this method if you want your Camera to use an exotic projection matrix. See also <a class="el" href="classqglviewer_1_1Camera.html#a81053f822008b76bff7b1a41dceedf53">loadModelViewMatrix()</a>.</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd><code>glMatrixMode</code> is set to <code>GL_PROJECTION</code>.</dd>
<dd>
If you use several OpenGL contexts and bypass the Qt main refresh loop, you should call QGLWidget::makeCurrent() before this method in order to activate the right OpenGL context. </dd></dl>

</div>
</div>
<a class="anchor" id="a79dac3c1bcb983c9025710b333f063a3"></a><!-- doxytag: member="qglviewer::Camera::loadProjectionMatrixStereo" ref="a79dac3c1bcb983c9025710b333f063a3" args="(bool leftBuffer=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void loadProjectionMatrixStereo </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>leftBuffer</em> = <code>true</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Same as <a class="el" href="classqglviewer_1_1Camera.html#a98a0679a22f005bbd8cc19756507cc9a">loadProjectionMatrix()</a> but for a stereo setup.</p>
<p>Only the <a class="el" href="classqglviewer_1_1Camera.html#a1d1cfd8ffb84e947f82999c682b666a7a2c5d7801888c03752f28943ac85d805f">Camera::PERSPECTIVE</a> <a class="el" href="classqglviewer_1_1Camera.html#afbd0fa31db28593e9669c3c56711c0a7">type()</a> is supported for stereo mode. See <a class="el" href="classQGLViewer.html#afe362ba5c3851a93f23fb833b2479f08">QGLViewer::setStereoDisplay()</a>.</p>
<p>Uses <a class="el" href="classqglviewer_1_1Camera.html#af201ce62f669c8944a276a2615951379">focusDistance()</a>, <a class="el" href="classqglviewer_1_1Camera.html#ad36e74de9c4020f951ea1a04e53a192d">IODistance()</a>, and <a class="el" href="classqglviewer_1_1Camera.html#a8418799b4eeb22cbc1a157d488dcf09c">physicalScreenWidth()</a> to compute cameras offset and asymmetric frustums.</p>
<p>When <code>leftBuffer</code> is <code>true</code>, computes the projection matrix associated to the left eye (right eye otherwise). See also <a class="el" href="classqglviewer_1_1Camera.html#a47c0f19a566d045a2872b44014be8392">loadModelViewMatrixStereo()</a>.</p>
<p>See the <a href="../examples/stereoViewer.html">stereoViewer</a> and the <a href="../examples/contribs.html#anaglyph">anaglyph</a> examples for an illustration.</p>
<p>To retrieve this matrix, use a code like: </p>
<div class="fragment"><pre class="fragment"> glMatrixMode(GL_PROJECTION);
 glPushMatrix();
 <a class="code" href="classqglviewer_1_1Camera.html#a79dac3c1bcb983c9025710b333f063a3">loadProjectionMatrixStereo</a>(left_or_right);
 glGetFloatv(GL_PROJECTION_MATRIX, m);
 glPopMatrix();
</pre></div><p> Note that <a class="el" href="classqglviewer_1_1Camera.html#a97ff5cf330a6c24d6d49308aedd638bc">getProjectionMatrix()</a> always returns the mono-vision matrix.</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>glMatrixMode is set to <code>GL_PROJECTION</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="aafe147ffa75738c296c729d9b5026446"></a><!-- doxytag: member="qglviewer::Camera::lookAt" ref="aafe147ffa75738c296c729d9b5026446" args="(const Vec &amp;target)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lookAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>target</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the Camera <a class="el" href="classqglviewer_1_1Camera.html#a691af39b54669fad8b4e73599de22094">orientation()</a>, so that it looks at point <code>target</code> (defined in the world coordinate system).</p>
<p>The Camera <a class="el" href="classqglviewer_1_1Camera.html#abc38a05a597e07c9ff525122682adc50">position()</a> is not modified. Simply <a class="el" href="classqglviewer_1_1Camera.html#a066c4058970a008d0d0a8ff442d117f6">setViewDirection()</a>.</p>
<p>See also <a class="el" href="classqglviewer_1_1Camera.html#ab442b71a46297223ae12b163653eeb7e">setUpVector()</a>, <a class="el" href="classqglviewer_1_1Camera.html#a3862c502f5afc626af2ff582390bc868">setOrientation()</a>, <a class="el" href="classqglviewer_1_1Camera.html#ada8dd7d2346ebf46ed1f9822a8418df2">showEntireScene()</a>, <a class="el" href="classqglviewer_1_1Camera.html#a424fbe98af0ca295c692d8d4ae73ceec">fitSphere()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a65a284702aab36f853d59ce6c7a082b9">fitBoundingBox()</a>. </p>

</div>
</div>
<a class="anchor" id="a0f87e84ad3356493738d4fc8331c7362"></a><!-- doxytag: member="qglviewer::Camera::operator=" ref="a0f87e84ad3356493738d4fc8331c7362" args="(const Camera &amp;camera)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Camera &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const Camera &amp;&nbsp;</td>
          <td class="paramname"> <em>camera</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Equal operator.</p>
<p>All the parameters of <code>camera</code> are copied. The <a class="el" href="classqglviewer_1_1Camera.html#ad367db656b03fe0bc87b021801d66b75">frame()</a> pointer is not modified, but its <a class="el" href="classqglviewer_1_1Frame.html#abc38a05a597e07c9ff525122682adc50">Frame::position()</a> and <a class="el" href="classqglviewer_1_1Frame.html#a691af39b54669fad8b4e73599de22094">Frame::orientation()</a> are set to those of <code>camera</code>.</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>The Camera <a class="el" href="classqglviewer_1_1Camera.html#a80386c5943505b915246563262825d8e">screenWidth()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a9fb925ffbf82e93898ae6db366a8d794">screenHeight()</a> are set to those of <code>camera</code>. If your Camera is associated with a <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a>, you should update these value after the call to this method: <div class="fragment"><pre class="fragment"> *(camera()) = otherCamera;
 camera()-&gt;setScreenWidthAndHeight(width(), height());
</pre></div> The same applies to <a class="el" href="classqglviewer_1_1Camera.html#a87bccbfd40649310f3da369af02d50b1">sceneCenter()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a58c17044cc4a601c6b446bf5e83513f9">sceneRadius()</a>, if needed. </dd></dl>

</div>
</div>
<a class="anchor" id="a691af39b54669fad8b4e73599de22094"></a><!-- doxytag: member="qglviewer::Camera::orientation" ref="a691af39b54669fad8b4e73599de22094" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqglviewer_1_1Quaternion.html">Quaternion</a> orientation </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the Camera orientation, defined in the world coordinate system.</p>
<p>Actually returns <code><a class="el" href="classqglviewer_1_1Camera.html#ad367db656b03fe0bc87b021801d66b75">frame()</a>-&gt;<a class="el" href="classqglviewer_1_1Camera.html#a691af39b54669fad8b4e73599de22094">orientation()</a></code>. Use <a class="el" href="classqglviewer_1_1Camera.html#a3862c502f5afc626af2ff582390bc868">setOrientation()</a>, <a class="el" href="classqglviewer_1_1Camera.html#ab442b71a46297223ae12b163653eeb7e">setUpVector()</a> or <a class="el" href="classqglviewer_1_1Camera.html#aafe147ffa75738c296c729d9b5026446">lookAt()</a> to set the Camera orientation. </p>

</div>
</div>
<a class="anchor" id="a2cbb7d182c56732a6129936c5dd19d64"></a><!-- doxytag: member="qglviewer::Camera::physicalDistanceToScreen" ref="a2cbb7d182c56732a6129936c5dd19d64" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float physicalDistanceToScreen </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the physical distance between the user's eyes and the screen (in meters).</p>
<p>Default value is 0.5m.</p>
<p>Used by <a class="el" href="classqglviewer_1_1Camera.html#a47c0f19a566d045a2872b44014be8392">loadModelViewMatrixStereo()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a79dac3c1bcb983c9025710b333f063a3">loadProjectionMatrixStereo()</a> for stereo display. Value is set using <a class="el" href="classqglviewer_1_1Camera.html#aa88668546aa531dc0702d1b005904bcf">setPhysicalDistanceToScreen()</a>.</p>
<p><a class="el" href="classqglviewer_1_1Camera.html#a2cbb7d182c56732a6129936c5dd19d64">physicalDistanceToScreen()</a> and <a class="el" href="classqglviewer_1_1Camera.html#af201ce62f669c8944a276a2615951379">focusDistance()</a> represent the same distance. The first one is expressed in physical real world units, while the latter is expressed in OpenGL virtual world units. Use their ratio to convert distances between these worlds.</p>
<p>Use the following code to detect a reality center configuration (using its screen aspect ratio) and to automatically set physical distances accordingly: </p>
<div class="fragment"><pre class="fragment">    QDesktopWidget screen;
    <span class="keywordflow">if</span> (fabs((<span class="keywordtype">float</span>)screen.width() / (float)screen.height()) &gt; 2.0)
    {
      camera()-&gt;setPhysicalDistanceToScreen(4.0);
      camera()-&gt;setPhysicalScreenWidth(10.0);
    }
</pre></div> 
</div>
</div>
<a class="anchor" id="a8418799b4eeb22cbc1a157d488dcf09c"></a><!-- doxytag: member="qglviewer::Camera::physicalScreenWidth" ref="a8418799b4eeb22cbc1a157d488dcf09c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float physicalScreenWidth </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the physical screen width, in meters. Default value is 0.4m (average monitor).</p>
<p>Used for stereo display only (see <a class="el" href="classqglviewer_1_1Camera.html#a47c0f19a566d045a2872b44014be8392">loadModelViewMatrixStereo()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a79dac3c1bcb983c9025710b333f063a3">loadProjectionMatrixStereo()</a>). Set using <a class="el" href="classqglviewer_1_1Camera.html#a34911cda1cc1bc13336024c844ff4401">setPhysicalScreenWidth()</a>.</p>
<p>See <a class="el" href="classqglviewer_1_1Camera.html#a2cbb7d182c56732a6129936c5dd19d64">physicalDistanceToScreen()</a> for reality center automatic configuration. </p>

</div>
</div>
<a class="anchor" id="a27f2dfd157643704c48630515a7f811f"></a><!-- doxytag: member="qglviewer::Camera::pixelGLRatio" ref="a27f2dfd157643704c48630515a7f811f" args="(const Vec &amp;position) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float pixelGLRatio </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the ratio between pixel and OpenGL units at <code>position</code>.</p>
<p>A line of <code>n</code> * <a class="el" href="classqglviewer_1_1Camera.html#a27f2dfd157643704c48630515a7f811f">pixelGLRatio()</a> OpenGL units, located at <code>position</code> in the world coordinates system, will be projected with a length of <code>n</code> pixels on screen.</p>
<p>Use this method to scale objects so that they have a constant pixel size on screen. The following code will draw a 20 pixel line, starting at <a class="el" href="classqglviewer_1_1Camera.html#a87bccbfd40649310f3da369af02d50b1">sceneCenter()</a> and always directed along the screen vertical direction: </p>
<div class="fragment"><pre class="fragment"> glBegin(GL_LINES);
 glVertex3fv(<a class="code" href="classqglviewer_1_1Camera.html#a87bccbfd40649310f3da369af02d50b1">sceneCenter</a>());
 glVertex3fv(<a class="code" href="classqglviewer_1_1Camera.html#a87bccbfd40649310f3da369af02d50b1">sceneCenter</a>() + 20 * <a class="code" href="classqglviewer_1_1Camera.html#a27f2dfd157643704c48630515a7f811f">pixelGLRatio</a>(<a class="code" href="classqglviewer_1_1Camera.html#a87bccbfd40649310f3da369af02d50b1">sceneCenter</a>()) * camera()-&gt;<a class="code" href="classqglviewer_1_1Camera.html#a9cd2e746e7379b08fbaeea0ced76e1d7">upVector</a>());
 glEnd();
</pre></div> 
</div>
</div>
<a class="anchor" id="a4eb47bb1cf02f806f1f355f63b445818"></a><!-- doxytag: member="qglviewer::Camera::playPath" ref="a4eb47bb1cf02f806f1f355f63b445818" args="(int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void playPath </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Makes the Camera follow the path of <a class="el" href="classqglviewer_1_1Camera.html#abfbef567a6bbb9163b31c6f46238e4de">keyFrameInterpolator()</a> number <code>i</code>.</p>
<p>If the interpolation is started, it stops it instead.</p>
<p>This method silently ignores undefined (empty) paths (see <a class="el" href="classqglviewer_1_1Camera.html#abfbef567a6bbb9163b31c6f46238e4de">keyFrameInterpolator()</a>).</p>
<p>The default keyboard shortcut for this method is F[1-12]. Set <a class="el" href="classQGLViewer.html#adfe21e109b45f8c79f2c360bf35fb835">QGLViewer::pathKey()</a> and <a class="el" href="classQGLViewer.html#a02cb4ab51746a7bb14d1fab077e94ea7">QGLViewer::playPathKeyboardModifiers()</a>. </p>

</div>
</div>
<a class="anchor" id="a90459767f782c80086ad7cff90a40b5a"></a><!-- doxytag: member="qglviewer::Camera::pointUnderPixel" ref="a90459767f782c80086ad7cff90a40b5a" args="(const QPoint &amp;pixel, bool &amp;found) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqglviewer_1_1Vec.html">Vec</a> pointUnderPixel </td>
          <td>(</td>
          <td class="paramtype">const QPoint &amp;&nbsp;</td>
          <td class="paramname"> <em>pixel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>found</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the coordinates of the 3D point located at pixel (x,y) on screen.</p>
<p>Calls a <code>glReadPixel</code> to get the pixel depth and applies an <a class="el" href="classqglviewer_1_1Camera.html#a42577d3077e22b4726d78b3db3bba50d">unprojectedCoordinatesOf()</a> to the result. <code>found</code> indicates whether a point was found or not (i.e. background pixel, result's depth is <a class="el" href="classqglviewer_1_1Camera.html#aa7461df81c1ea0384d4c64723eb7b949">zFar()</a> in that case).</p>
<p><code>x</code> and <code>y</code> are expressed in pixel units with an origin in the upper left corner. Use <a class="el" href="classqglviewer_1_1Camera.html#a9fb925ffbf82e93898ae6db366a8d794">screenHeight()</a> - y to convert to OpenGL standard.</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>This method assumes that a GL context is available, and that its content was drawn using the Camera (i.e. using its projection and modelview matrices). This method hence cannot be used for offscreen Camera computations. Use <a class="el" href="classqglviewer_1_1Camera.html#a5dd8eca926558c252d7552d85079880a">cameraCoordinatesOf()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a123ad9bda6d715b5370650c2514896ab">worldCoordinatesOf()</a> to perform similar operations in that case.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The precision of the z-Buffer highly depends on how the <a class="el" href="classqglviewer_1_1Camera.html#a419a57556a6681c3a0489c847d687ea5">zNear()</a> and <a class="el" href="classqglviewer_1_1Camera.html#aa7461df81c1ea0384d4c64723eb7b949">zFar()</a> values are fitted to your scene. Loose boundaries will result in imprecision along the viewing direction. </dd></dl>

</div>
</div>
<a class="anchor" id="abc38a05a597e07c9ff525122682adc50"></a><!-- doxytag: member="qglviewer::Camera::position" ref="abc38a05a597e07c9ff525122682adc50" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqglviewer_1_1Vec.html">Vec</a> position </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the Camera position (the eye), defined in the world coordinate system.</p>
<p>Use <a class="el" href="classqglviewer_1_1Camera.html#a212edb01759f542f356c5d62e4a3f821">setPosition()</a> to set the Camera position. Other convenient methods are <a class="el" href="classqglviewer_1_1Camera.html#ada8dd7d2346ebf46ed1f9822a8418df2">showEntireScene()</a> or <a class="el" href="classqglviewer_1_1Camera.html#a424fbe98af0ca295c692d8d4ae73ceec">fitSphere()</a>. Actually returns <code><a class="el" href="classqglviewer_1_1Camera.html#ad367db656b03fe0bc87b021801d66b75">frame()</a>-&gt;<a class="el" href="classqglviewer_1_1Camera.html#abc38a05a597e07c9ff525122682adc50">position()</a></code>.</p>
<p>This position corresponds to the projection center of a <a class="el" href="classqglviewer_1_1Camera.html#a1d1cfd8ffb84e947f82999c682b666a7a2c5d7801888c03752f28943ac85d805f">Camera::PERSPECTIVE</a> Camera. It is not located in the image plane, which is at a <a class="el" href="classqglviewer_1_1Camera.html#a419a57556a6681c3a0489c847d687ea5">zNear()</a> distance ahead. </p>

</div>
</div>
<a class="anchor" id="ac4dc649d17bd2ae8664a7f4fdd50360f"></a><!-- doxytag: member="qglviewer::Camera::projectedCoordinatesOf" ref="ac4dc649d17bd2ae8664a7f4fdd50360f" args="(const Vec &amp;src, const Frame *frame=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqglviewer_1_1Vec.html">Vec</a> projectedCoordinatesOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classqglviewer_1_1Frame.html">Frame</a> *&nbsp;</td>
          <td class="paramname"> <em>frame</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the screen projected coordinates of a point <code>src</code> defined in the <code>frame</code> coordinate system.</p>
<p>When <code>frame</code> in <code>NULL</code> (default), <code>src</code> is expressed in the world coordinate system.</p>
<p>The x and y coordinates of the returned <a class="el" href="classqglviewer_1_1Vec.html" title="The Vec class represents 3D positions and 3D vectors.">Vec</a> are expressed in pixel, (0,0) being the <em>upper</em> left corner of the window. The z coordinate ranges between 0.0 (near plane) and 1.0 (excluded, far plane). See the <code>gluProject</code> man page for details.</p>
<p><a class="el" href="classqglviewer_1_1Camera.html#a42577d3077e22b4726d78b3db3bba50d">unprojectedCoordinatesOf()</a> performs the inverse transformation.</p>
<p>See the <a href="../examples/screenCoordSystem.html">screenCoordSystem example</a>.</p>
<p>This method only uses the intrinsic Camera parameters (see <a class="el" href="classqglviewer_1_1Camera.html#aa1d631d6e368a7aa14656b7511787786">getModelViewMatrix()</a>, <a class="el" href="classqglviewer_1_1Camera.html#a97ff5cf330a6c24d6d49308aedd638bc">getProjectionMatrix()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a5034f21055f864c1ade7d86fec209348">getViewport()</a>) and is completely independent of the OpenGL <code>GL_MODELVIEW</code>, <code>GL_PROJECTION</code> and viewport matrices. You can hence define a virtual Camera and use this method to compute projections out of a classical rendering context.</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>However, if your Camera is not attached to a <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a> (used for offscreen computations for instance), make sure the Camera matrices are updated before calling this method. Call <a class="el" href="classqglviewer_1_1Camera.html#a0dad4baab6008e5a94e8a2fa83ec0f05">computeModelViewMatrix()</a> and <a class="el" href="classqglviewer_1_1Camera.html#ae51b6c486fe6448453369174bbea8055">computeProjectionMatrix()</a> to do so.</dd></dl>
<p>If you call this method several times with no change in the matrices, consider precomputing the projection times modelview matrix to save computation time if required (<code>P</code> x <code>M</code> in the <code>gluProject</code> man page).</p>
<p>Here is the code corresponding to what this method does (kindly submitted by Robert W. Kuhn) : </p>
<div class="fragment"><pre class="fragment"> Vec project(Vec point)
 {
        GLint    Viewport[4];
        GLdouble Projection[16], Modelview[16]; 
        GLdouble matrix[16];

        <span class="comment">// Precomputation begin</span>
        glGetIntegerv(GL_VIEWPORT         , Viewport);
        glGetDoublev (GL_MODELVIEW_MATRIX , Modelview);
        glGetDoublev (GL_PROJECTION_MATRIX, Projection); 

        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> m=0; m&lt;4; ++m)
        {
                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> l=0; l&lt;4; ++l)
                {
                        <span class="keywordtype">double</span> sum = 0.0;
                        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> k=0; k&lt;4; ++k)
                                sum += Projection[l+4*k]*Modelview[k+4*m];
                        matrix[l+4*m] = sum;
                }
        }
        <span class="comment">// Precomputation end</span>
                
        GLdouble v[4], vs[4];
        v[0]=point[0]; v[1]=point[1]; v[2]=point[2]; v[3]=1.0;

        vs[0]=matrix[0 ]*v[0] + matrix[4 ]*v[1] + matrix[8 ]*v[2] + matrix[12 ]*v[3];
        vs[1]=matrix[1 ]*v[0] + matrix[5 ]*v[1] + matrix[9 ]*v[2] + matrix[13 ]*v[3];
        vs[2]=matrix[2 ]*v[0] + matrix[6 ]*v[1] + matrix[10]*v[2] + matrix[14 ]*v[3];
        vs[3]=matrix[3 ]*v[0] + matrix[7 ]*v[1] + matrix[11]*v[2] + matrix[15 ]*v[3];

        vs[0] /= vs[3];
        vs[1] /= vs[3];
        vs[2] /= vs[3];

        vs[0] = vs[0] * 0.5 + 0.5;
        vs[1] = vs[1] * 0.5 + 0.5;
        vs[2] = vs[2] * 0.5 + 0.5;

        vs[0] = vs[0] * Viewport[2] + Viewport[0];
        vs[1] = vs[1] * Viewport[3] + Viewport[1];

        <span class="keywordflow">return</span> Vec(vs[0], Viewport[3]-vs[1], vs[2]);    
  }
</pre></div> 
</div>
</div>
<a class="anchor" id="ae0329e473f00bb56f1e9949b8423ecbf"></a><!-- doxytag: member="qglviewer::Camera::resetPath" ref="ae0329e473f00bb56f1e9949b8423ecbf" args="(int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void resetPath </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resets the path of the <a class="el" href="classqglviewer_1_1Camera.html#abfbef567a6bbb9163b31c6f46238e4de">keyFrameInterpolator()</a> number <code>i</code>.</p>
<p>If this path is <em>not</em> being played (see <a class="el" href="classqglviewer_1_1Camera.html#a4eb47bb1cf02f806f1f355f63b445818">playPath()</a> and <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html#a8cc0fa56ba7b6da71226cc191cc18e70">KeyFrameInterpolator::interpolationIsStarted()</a>), resets it to is its starting position (see <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html#a0bfc602dc2fcaca40cc49195bba7ba74">KeyFrameInterpolator::resetInterpolation()</a>). If the path is played, simply stops interpolation. </p>

</div>
</div>
<a class="anchor" id="afd168442e2a05bd41881936fb722b5fe"></a><!-- doxytag: member="qglviewer::Camera::revolveAroundPoint" ref="afd168442e2a05bd41881936fb722b5fe" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqglviewer_1_1Vec.html">Vec</a> revolveAroundPoint </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The point the Camera revolves around with the <a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875a3dcfe0046eb5876e287dbf0914819b16">ROTATE</a> mouse binding. Defined in world coordinate system.</p>
<p>Default value is the <a class="el" href="classqglviewer_1_1Camera.html#a87bccbfd40649310f3da369af02d50b1">sceneCenter()</a>.</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd><a class="el" href="classqglviewer_1_1Camera.html#a9185df6d9e8fbc108f83c5355f5e7b33">setSceneCenter()</a> changes this value. </dd></dl>

</div>
</div>
<a class="anchor" id="a99f766869c7cc9faaf9a5337db6f223c"></a><!-- doxytag: member="qglviewer::Camera::rightVector" ref="a99f766869c7cc9faaf9a5337db6f223c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqglviewer_1_1Vec.html">Vec</a> rightVector </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the normalized right vector of the Camera, defined in the world coordinate system.</p>
<p>This vector lies in the Camera horizontal plane, directed along the X axis (orthogonal to <a class="el" href="classqglviewer_1_1Camera.html#a9cd2e746e7379b08fbaeea0ced76e1d7">upVector()</a> and to <a class="el" href="classqglviewer_1_1Camera.html#aac10e453c166209b4e6c14c0266651c7">viewDirection()</a>). Set using <a class="el" href="classqglviewer_1_1Camera.html#ab442b71a46297223ae12b163653eeb7e">setUpVector()</a>, <a class="el" href="classqglviewer_1_1Camera.html#aafe147ffa75738c296c729d9b5026446">lookAt()</a> or <a class="el" href="classqglviewer_1_1Camera.html#a3862c502f5afc626af2ff582390bc868">setOrientation()</a>.</p>
<p>Simply returns <a class="el" href="classqglviewer_1_1Camera.html#ad367db656b03fe0bc87b021801d66b75">frame()</a>-&gt;inverseTransformOf(<a class="el" href="classqglviewer_1_1Vec.html" title="The Vec class represents 3D positions and 3D vectors.">Vec</a>(1.0, 0.0, 0.0)). </p>

</div>
</div>
<a class="anchor" id="a87bccbfd40649310f3da369af02d50b1"></a><!-- doxytag: member="qglviewer::Camera::sceneCenter" ref="a87bccbfd40649310f3da369af02d50b1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqglviewer_1_1Vec.html">Vec</a> sceneCenter </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the position of the scene center, defined in the world coordinate system.</p>
<p>The scene observed by the Camera should be roughly centered on this position, and included in a <a class="el" href="classqglviewer_1_1Camera.html#a58c17044cc4a601c6b446bf5e83513f9">sceneRadius()</a> sphere. This approximate description of the scene permits a <a class="el" href="classqglviewer_1_1Camera.html#a419a57556a6681c3a0489c847d687ea5">zNear()</a> and <a class="el" href="classqglviewer_1_1Camera.html#aa7461df81c1ea0384d4c64723eb7b949">zFar()</a> clipping planes definition, and allows convenient positioning methods such as <a class="el" href="classqglviewer_1_1Camera.html#ada8dd7d2346ebf46ed1f9822a8418df2">showEntireScene()</a>.</p>
<p>Default value is (0,0,0) (world origin). Use <a class="el" href="classqglviewer_1_1Camera.html#a9185df6d9e8fbc108f83c5355f5e7b33">setSceneCenter()</a> to change it. See also <a class="el" href="classqglviewer_1_1Camera.html#af3a1c2682cba52d6339d2f565ea1d0ee">setSceneBoundingBox()</a>.</p>
<p>Note that <a class="el" href="classQGLViewer.html#a5a0503bc22a710f96bfd779eaf538bab">QGLViewer::sceneCenter()</a> (resp. <a class="el" href="classQGLViewer.html#a6712acd05f9d518d6babfe96e537d06d">QGLViewer::setSceneCenter()</a>) simply call this method (resp. <a class="el" href="classqglviewer_1_1Camera.html#a9185df6d9e8fbc108f83c5355f5e7b33">setSceneCenter()</a>) on its associated <a class="el" href="classQGLViewer.html#a27a9e97573822d296b48e1c408b74042">QGLViewer::camera()</a>. </p>

</div>
</div>
<a class="anchor" id="a58c17044cc4a601c6b446bf5e83513f9"></a><!-- doxytag: member="qglviewer::Camera::sceneRadius" ref="a58c17044cc4a601c6b446bf5e83513f9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float sceneRadius </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the radius of the scene observed by the Camera.</p>
<p>You need to provide such an approximation of the scene dimensions so that the Camera can adapt its <a class="el" href="classqglviewer_1_1Camera.html#a419a57556a6681c3a0489c847d687ea5">zNear()</a> and <a class="el" href="classqglviewer_1_1Camera.html#aa7461df81c1ea0384d4c64723eb7b949">zFar()</a> values. See the <a class="el" href="classqglviewer_1_1Camera.html#a87bccbfd40649310f3da369af02d50b1">sceneCenter()</a> documentation.</p>
<p>See also <a class="el" href="classqglviewer_1_1Camera.html#af3a1c2682cba52d6339d2f565ea1d0ee">setSceneBoundingBox()</a>.</p>
<p>Note that <a class="el" href="classQGLViewer.html#a58c17044cc4a601c6b446bf5e83513f9">QGLViewer::sceneRadius()</a> (resp. <a class="el" href="classQGLViewer.html#aef99f105486d457f0199fcc35181fa83">QGLViewer::setSceneRadius()</a>) simply call this method (resp. <a class="el" href="classqglviewer_1_1Camera.html#a33c70507fea15c3ea49a561b743ed822">setSceneRadius()</a>) on its associated <a class="el" href="classQGLViewer.html#a27a9e97573822d296b48e1c408b74042">QGLViewer::camera()</a>. </p>

</div>
</div>
<a class="anchor" id="a9fb925ffbf82e93898ae6db366a8d794"></a><!-- doxytag: member="qglviewer::Camera::screenHeight" ref="a9fb925ffbf82e93898ae6db366a8d794" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int screenHeight </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the height (in pixels) of the Camera screen.</p>
<p>Set using <a class="el" href="classqglviewer_1_1Camera.html#a504c573cdd26be8b717a6da9fdb41812">setScreenWidthAndHeight()</a>. This value is automatically fitted to the QGLViewer's window dimensions when the Camera is attached to a <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a>. See also QGLWidget::height() </p>

</div>
</div>
<a class="anchor" id="a80386c5943505b915246563262825d8e"></a><!-- doxytag: member="qglviewer::Camera::screenWidth" ref="a80386c5943505b915246563262825d8e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int screenWidth </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the width (in pixels) of the Camera screen.</p>
<p>Set using <a class="el" href="classqglviewer_1_1Camera.html#a504c573cdd26be8b717a6da9fdb41812">setScreenWidthAndHeight()</a>. This value is automatically fitted to the QGLViewer's window dimensions when the Camera is attached to a <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a>. See also QGLWidget::width() </p>

</div>
</div>
<a class="anchor" id="a5b191e9b12b704a05302b5d922792e9c"></a><!-- doxytag: member="qglviewer::Camera::setAspectRatio" ref="a5b191e9b12b704a05302b5d922792e9c" args="(float aspect)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setAspectRatio </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>aspect</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Defines the Camera <a class="el" href="classqglviewer_1_1Camera.html#a915589f4d93e15d110444ed9b3464fa1">aspectRatio()</a>.</p>
<p>This value is actually inferred from the <a class="el" href="classqglviewer_1_1Camera.html#a80386c5943505b915246563262825d8e">screenWidth()</a> / <a class="el" href="classqglviewer_1_1Camera.html#a9fb925ffbf82e93898ae6db366a8d794">screenHeight()</a> ratio. You should use <a class="el" href="classqglviewer_1_1Camera.html#a504c573cdd26be8b717a6da9fdb41812">setScreenWidthAndHeight()</a> instead.</p>
<p>This method might however be convenient when the Camera is not associated with a <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a>. It actually sets the <a class="el" href="classqglviewer_1_1Camera.html#a9fb925ffbf82e93898ae6db366a8d794">screenHeight()</a> to 100 and the <a class="el" href="classqglviewer_1_1Camera.html#a80386c5943505b915246563262825d8e">screenWidth()</a> accordingly. See also <a class="el" href="classqglviewer_1_1Camera.html#a3394c425f95c5649b1e2e532dbd97fa7">setFOVToFitScene()</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If you absolutely need an <a class="el" href="classqglviewer_1_1Camera.html#a915589f4d93e15d110444ed9b3464fa1">aspectRatio()</a> that does not correspond to your viewer's window dimensions, overload <a class="el" href="classqglviewer_1_1Camera.html#a98a0679a22f005bbd8cc19756507cc9a">loadProjectionMatrix()</a> or multiply the created GL_PROJECTION matrix by a scaled diagonal matrix in your <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">QGLViewer::draw()</a> method. </dd></dl>

</div>
</div>
<a class="anchor" id="a524f0183a127bb004defe3c2f7614e4c"></a><!-- doxytag: member="qglviewer::Camera::setFieldOfView" ref="a524f0183a127bb004defe3c2f7614e4c" args="(float fov)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setFieldOfView </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>fov</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the vertical <a class="el" href="classqglviewer_1_1Camera.html#a89f1a2e62f7edf51de2d1c077ea5d330">fieldOfView()</a> of the Camera (in radians).</p>
<p>Note that <a class="el" href="classqglviewer_1_1Camera.html#af201ce62f669c8944a276a2615951379">focusDistance()</a> is set to <a class="el" href="classqglviewer_1_1Camera.html#a58c17044cc4a601c6b446bf5e83513f9">sceneRadius()</a> / tan(<a class="el" href="classqglviewer_1_1Camera.html#a89f1a2e62f7edf51de2d1c077ea5d330">fieldOfView()</a>/2) by this method. </p>

</div>
</div>
<a class="anchor" id="a02765efeaae1ef24f9d899f0d1d9ca09"></a><!-- doxytag: member="qglviewer::Camera::setFlySpeed" ref="a02765efeaae1ef24f9d899f0d1d9ca09" args="(float speed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setFlySpeed </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>speed</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the Camera <a class="el" href="classqglviewer_1_1Camera.html#ac1758b72dab0895b9340fa833e62b802">flySpeed()</a>.</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>This value is modified by <a class="el" href="classqglviewer_1_1Camera.html#a33c70507fea15c3ea49a561b743ed822">setSceneRadius()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a863ffb0284b534d5c57ac64a98e5e49a"></a><!-- doxytag: member="qglviewer::Camera::setFocusDistance" ref="a863ffb0284b534d5c57ac64a98e5e49a" args="(float distance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setFocusDistance </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>distance</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the <a class="el" href="classqglviewer_1_1Camera.html#af201ce62f669c8944a276a2615951379">focusDistance()</a>, in OpenGL scene units. </p>

</div>
</div>
<a class="anchor" id="a3394c425f95c5649b1e2e532dbd97fa7"></a><!-- doxytag: member="qglviewer::Camera::setFOVToFitScene" ref="a3394c425f95c5649b1e2e532dbd97fa7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setFOVToFitScene </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Changes the Camera <a class="el" href="classqglviewer_1_1Camera.html#a89f1a2e62f7edf51de2d1c077ea5d330">fieldOfView()</a> so that the entire scene (defined by <a class="el" href="classQGLViewer.html#a5a0503bc22a710f96bfd779eaf538bab">QGLViewer::sceneCenter()</a> and <a class="el" href="classQGLViewer.html#a58c17044cc4a601c6b446bf5e83513f9">QGLViewer::sceneRadius()</a>) is visible from the Camera <a class="el" href="classqglviewer_1_1Camera.html#abc38a05a597e07c9ff525122682adc50">position()</a>.</p>
<p>The <a class="el" href="classqglviewer_1_1Camera.html#abc38a05a597e07c9ff525122682adc50">position()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a691af39b54669fad8b4e73599de22094">orientation()</a> of the Camera are not modified and you first have to orientate the Camera in order to actually see the scene (see <a class="el" href="classqglviewer_1_1Camera.html#aafe147ffa75738c296c729d9b5026446">lookAt()</a>, <a class="el" href="classqglviewer_1_1Camera.html#ada8dd7d2346ebf46ed1f9822a8418df2">showEntireScene()</a> or <a class="el" href="classqglviewer_1_1Camera.html#a424fbe98af0ca295c692d8d4ae73ceec">fitSphere()</a>).</p>
<p>This method is especially useful for <em>shadow</em> <em>maps</em> computation. Use the Camera positioning tools (<a class="el" href="classqglviewer_1_1Camera.html#a212edb01759f542f356c5d62e4a3f821">setPosition()</a>, <a class="el" href="classqglviewer_1_1Camera.html#aafe147ffa75738c296c729d9b5026446">lookAt()</a>) to position a Camera at the light position. Then use this method to define the <a class="el" href="classqglviewer_1_1Camera.html#a89f1a2e62f7edf51de2d1c077ea5d330">fieldOfView()</a> so that the shadow map resolution is optimally used: </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// The light camera needs size hints in order to optimize its fieldOfView</span>
 lightCamera-&gt;setSceneRadius(<a class="code" href="classqglviewer_1_1Camera.html#a58c17044cc4a601c6b446bf5e83513f9">sceneRadius</a>());
 lightCamera-&gt;setSceneCenter(<a class="code" href="classqglviewer_1_1Camera.html#a87bccbfd40649310f3da369af02d50b1">sceneCenter</a>());

 <span class="comment">// Place the light camera.</span>
 lightCamera-&gt;setPosition(lightFrame-&gt;position());
 lightCamera-&gt;lookAt(<a class="code" href="classqglviewer_1_1Camera.html#a87bccbfd40649310f3da369af02d50b1">sceneCenter</a>());
 lightCamera-&gt;setFOVToFitScene();
</pre></div><p>See the (soon available) shadowMap contribution example for a practical implementation.</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>The <a class="el" href="classqglviewer_1_1Camera.html#a89f1a2e62f7edf51de2d1c077ea5d330">fieldOfView()</a> is clamped to M_PI/2.0. This happens when the Camera is at a distance lower than sqrt(2.0) * <a class="el" href="classqglviewer_1_1Camera.html#a58c17044cc4a601c6b446bf5e83513f9">sceneRadius()</a> from the <a class="el" href="classqglviewer_1_1Camera.html#a87bccbfd40649310f3da369af02d50b1">sceneCenter()</a>. It optimizes the shadow map resolution, although it may miss some parts of the scene. </dd></dl>

</div>
</div>
<a class="anchor" id="a809bad30c861f4f6f74228fb59340f90"></a><!-- doxytag: member="qglviewer::Camera::setFrame" ref="a809bad30c861f4f6f74228fb59340f90" args="(ManipulatedCameraFrame *const mcf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classqglviewer_1_1ManipulatedCameraFrame.html">ManipulatedCameraFrame</a> *const &nbsp;</td>
          <td class="paramname"> <em>mcf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the Camera <a class="el" href="classqglviewer_1_1Camera.html#ad367db656b03fe0bc87b021801d66b75">frame()</a>.</p>
<p>If you want to move the Camera, use <a class="el" href="classqglviewer_1_1Camera.html#a212edb01759f542f356c5d62e4a3f821">setPosition()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a3862c502f5afc626af2ff582390bc868">setOrientation()</a> or one of the Camera positioning methods (<a class="el" href="classqglviewer_1_1Camera.html#aafe147ffa75738c296c729d9b5026446">lookAt()</a>, <a class="el" href="classqglviewer_1_1Camera.html#a424fbe98af0ca295c692d8d4ae73ceec">fitSphere()</a>, <a class="el" href="classqglviewer_1_1Camera.html#ada8dd7d2346ebf46ed1f9822a8418df2">showEntireScene()</a>...) instead.</p>
<p>If you want to save the Camera <a class="el" href="classqglviewer_1_1Camera.html#abc38a05a597e07c9ff525122682adc50">position()</a>, there's no need to call this method either. Use <a class="el" href="classqglviewer_1_1Camera.html#a804ee001a41c3ddc33948447fc555cec">addKeyFrameToPath()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a4eb47bb1cf02f806f1f355f63b445818">playPath()</a> instead.</p>
<p>This method is actually mainly useful if you derive the <a class="el" href="classqglviewer_1_1ManipulatedCameraFrame.html" title="The ManipulatedCameraFrame class represents a ManipulatedFrame with Camera specific...">ManipulatedCameraFrame</a> class and want to use an instance of your new class to move the Camera.</p>
<p>A <code>NULL</code> <code>mcf</code> pointer will silently be ignored. The calling method is responsible for deleting the previous <a class="el" href="classqglviewer_1_1Camera.html#ad367db656b03fe0bc87b021801d66b75">frame()</a> pointer if needed in order to prevent memory leaks. </p>

</div>
</div>
<a class="anchor" id="ab21e4c76205431bdeba645a5f258dce9"></a><!-- doxytag: member="qglviewer::Camera::setFromModelViewMatrix" ref="ab21e4c76205431bdeba645a5f258dce9" args="(const GLdouble *const modelViewMatrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setFromModelViewMatrix </td>
          <td>(</td>
          <td class="paramtype">const GLdouble *const &nbsp;</td>
          <td class="paramname"> <em>modelViewMatrix</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the Camera's <a class="el" href="classqglviewer_1_1Camera.html#abc38a05a597e07c9ff525122682adc50">position()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a691af39b54669fad8b4e73599de22094">orientation()</a> from an OpenGL ModelView matrix.</p>
<p>This enables a Camera initialisation from an other OpenGL application. <code>modelView</code> is a 16 GLdouble vector representing a valid OpenGL ModelView matrix, such as one can get using: </p>
<div class="fragment"><pre class="fragment">GLdouble mvm[16];
glGetDoublev(GL_MODELVIEW_MATRIX, mvm);
myCamera-&gt;setFromModelViewMatrix(mvm);
</pre></div><p>After this method has been called, <a class="el" href="classqglviewer_1_1Camera.html#aa1d631d6e368a7aa14656b7511787786">getModelViewMatrix()</a> returns a matrix equivalent to <code>modelView</code>.</p>
<p>Only the <a class="el" href="classqglviewer_1_1Camera.html#a691af39b54669fad8b4e73599de22094">orientation()</a> and <a class="el" href="classqglviewer_1_1Camera.html#abc38a05a597e07c9ff525122682adc50">position()</a> of the Camera are modified.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If you defined your matrix as <code>GLdouble</code> <code>mvm</code>[4][4], pass <code>&amp;</code>(mvm[0][0]) as a parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="ac49280735bce44665a4eabb166f10fcd"></a><!-- doxytag: member="qglviewer::Camera::setFromProjectionMatrix" ref="ac49280735bce44665a4eabb166f10fcd" args="(const float matrix[12])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setFromProjectionMatrix </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>matrix</em>[12]</td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Defines the Camera <a class="el" href="classqglviewer_1_1Camera.html#abc38a05a597e07c9ff525122682adc50">position()</a>, <a class="el" href="classqglviewer_1_1Camera.html#a691af39b54669fad8b4e73599de22094">orientation()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a89f1a2e62f7edf51de2d1c077ea5d330">fieldOfView()</a> from a projection matrix.</p>
<p><code>matrix</code> has to be given in the format used by vision algorithm. It has 3 lines and 4 columns. It transforms a point from the world homogeneous coordinate system (4 coordinates: <code>sx</code>, <code>sy</code>, <code>sz</code> and <code>s</code>) into a point in the screen homogeneous coordinate system (3 coordinates: <code>sx</code>, <code>sy</code>, and <code>s</code>, where <code>x</code> and <code>y</code> are the pixel coordinates on the screen).</p>
<p>Its three lines correspond to the homogeneous coordinates of the normals to the planes x=0, y=0 and z=0, defined in the Camera coordinate system.</p>
<p>The elements of the matrix are ordered in line major order: you can call <code>setFromProjectionMatrix</code>(&amp;(matrix[0][0])) if you defined your matrix as a <code>float</code> <code>matrix</code>[3][4].</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>Passing the result of <a class="el" href="classqglviewer_1_1Camera.html#a97ff5cf330a6c24d6d49308aedd638bc">getProjectionMatrix()</a> or <a class="el" href="classqglviewer_1_1Camera.html#aa1d631d6e368a7aa14656b7511787786">getModelViewMatrix()</a> to this method is not possible (purposefully incompatible matrix dimensions). <code>matrix</code> is more likely to be the product of these two matrices, without the last line.</dd></dl>
<p>Use <a class="el" href="classqglviewer_1_1Camera.html#ab21e4c76205431bdeba645a5f258dce9">setFromModelViewMatrix()</a> to set <a class="el" href="classqglviewer_1_1Camera.html#abc38a05a597e07c9ff525122682adc50">position()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a691af39b54669fad8b4e73599de22094">orientation()</a> from a <code>GL_MODELVIEW</code> matrix. <a class="el" href="classqglviewer_1_1Camera.html#a89f1a2e62f7edf51de2d1c077ea5d330">fieldOfView()</a> can also be retrieved from a <em>perspective</em> <code>GL_PROJECTION</code> matrix using 2.0 * atan(1.0/projectionMatrix[5]).</p>
<p>This code was written by Sylvain Paris. </p>

</div>
</div>
<a class="anchor" id="a017ace2ed5f67b6aeaef5c9a47b5f014"></a><!-- doxytag: member="qglviewer::Camera::setHorizontalFieldOfView" ref="a017ace2ed5f67b6aeaef5c9a47b5f014" args="(float hfov)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setHorizontalFieldOfView </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>hfov</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the <a class="el" href="classqglviewer_1_1Camera.html#a957cf1049788f7aba3dd16f20f565960">horizontalFieldOfView()</a> of the Camera (in radians).</p>
<p><a class="el" href="classqglviewer_1_1Camera.html#a957cf1049788f7aba3dd16f20f565960">horizontalFieldOfView()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a89f1a2e62f7edf51de2d1c077ea5d330">fieldOfView()</a> are linked by the <a class="el" href="classqglviewer_1_1Camera.html#a915589f4d93e15d110444ed9b3464fa1">aspectRatio()</a>. This method actually calls setFieldOfView(( 2.0 * atan (tan(hfov / 2.0) / <a class="el" href="classqglviewer_1_1Camera.html#a915589f4d93e15d110444ed9b3464fa1">aspectRatio()</a>) )) so that a call to <a class="el" href="classqglviewer_1_1Camera.html#a957cf1049788f7aba3dd16f20f565960">horizontalFieldOfView()</a> returns the expected value. </p>

</div>
</div>
<a class="anchor" id="a6cd81fe74a9dfe5c7124d00341ad0234"></a><!-- doxytag: member="qglviewer::Camera::setIODistance" ref="a6cd81fe74a9dfe5c7124d00341ad0234" args="(float distance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setIODistance </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>distance</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the <a class="el" href="classqglviewer_1_1Camera.html#ad36e74de9c4020f951ea1a04e53a192d">IODistance()</a>. </p>

</div>
</div>
<a class="anchor" id="a049b63c8c9ef48e24446ce44a3bd32b5"></a><!-- doxytag: member="qglviewer::Camera::setKeyFrameInterpolator" ref="a049b63c8c9ef48e24446ce44a3bd32b5" args="(int i, KeyFrameInterpolator *const kfi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setKeyFrameInterpolator </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html">KeyFrameInterpolator</a> *const &nbsp;</td>
          <td class="paramname"> <em>kfi</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html" title="A keyFrame Catmull-Rom Frame interpolator.">KeyFrameInterpolator</a> that defines the Camera path of index <code>i</code>.</p>
<p>The previous <a class="el" href="classqglviewer_1_1Camera.html#abfbef567a6bbb9163b31c6f46238e4de">keyFrameInterpolator()</a> is lost and should be deleted by the calling method if needed.</p>
<p>The <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html#ab55c2a4f1732b90057fae4b6037399de">KeyFrameInterpolator::interpolated()</a> signal of <code>kfi</code> probably needs to be connected to the Camera's associated <a class="el" href="classQGLViewer.html#ae12b7378efbffabc24a133ca1deb19ae">QGLViewer::updateGL()</a> slot, so that when the Camera position is interpolated using <code>kfi</code>, every interpolation step updates the display: </p>
<div class="fragment"><pre class="fragment"> myViewer.camera()-&gt;deletePath(3);
 myViewer.camera()-&gt;setKeyFrameInterpolator(3, myKeyFrameInterpolator);
 connect(myKeyFrameInterpolator, SIGNAL(interpolated()), myViewer, SLOT(updateGL());
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>These connections are done automatically when a Camera is attached to a <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a>, or when a new <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html" title="A keyFrame Catmull-Rom Frame interpolator.">KeyFrameInterpolator</a> is defined using the <a class="el" href="classQGLViewer.html#a7c91f5b77f92266cff3fe4ef99847b93">QGLViewer::addKeyFrameKeyboardModifiers()</a> and <a class="el" href="classQGLViewer.html#adfe21e109b45f8c79f2c360bf35fb835">QGLViewer::pathKey()</a> (default is Alt+F[1-12]). See the <a href="../keyboard.html">keyboard page</a> for details. </dd></dl>

</div>
</div>
<a class="anchor" id="a1842836742cf1ed8a33f32a863a5a05e"></a><!-- doxytag: member="qglviewer::Camera::setOrientation" ref="a1842836742cf1ed8a33f32a863a5a05e" args="(float theta, float phi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setOrientation </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>phi</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the <a class="el" href="classqglviewer_1_1Camera.html#a691af39b54669fad8b4e73599de22094">orientation()</a> of the Camera using polar coordinates.</p>
<p><code>theta</code> rotates the Camera around its Y axis, and <em>then</em> <code>phi</code> rotates it around its X axis. The polar coordinates are defined in the world coordinates system: <code>theta</code> = <code>phi</code> = 0 means that the Camera is directed towards the world Z axis. Both angles are expressed in radians.</p>
<p>See also <a class="el" href="classqglviewer_1_1Camera.html#ab442b71a46297223ae12b163653eeb7e">setUpVector()</a>. The <a class="el" href="classqglviewer_1_1Camera.html#abc38a05a597e07c9ff525122682adc50">position()</a> of the Camera is unchanged, you may want to call <a class="el" href="classqglviewer_1_1Camera.html#ada8dd7d2346ebf46ed1f9822a8418df2">showEntireScene()</a> after this method to move the Camera.</p>
<p>This method can be useful to create Quicktime VR panoramic sequences, see the <a class="el" href="classQGLViewer.html#a1cf2ffb973b096b249dc7e90327a2a8e">QGLViewer::saveSnapshot()</a> documentation for details. </p>

</div>
</div>
<a class="anchor" id="a3862c502f5afc626af2ff582390bc868"></a><!-- doxytag: member="qglviewer::Camera::setOrientation" ref="a3862c502f5afc626af2ff582390bc868" args="(const Quaternion &amp;q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setOrientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqglviewer_1_1Quaternion.html">Quaternion</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the Camera <a class="el" href="classqglviewer_1_1Camera.html#a691af39b54669fad8b4e73599de22094">orientation()</a>, defined in the world coordinate system. </p>

</div>
</div>
<a class="anchor" id="aa88668546aa531dc0702d1b005904bcf"></a><!-- doxytag: member="qglviewer::Camera::setPhysicalDistanceToScreen" ref="aa88668546aa531dc0702d1b005904bcf" args="(float distance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setPhysicalDistanceToScreen </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>distance</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the <a class="el" href="classqglviewer_1_1Camera.html#a2cbb7d182c56732a6129936c5dd19d64">physicalDistanceToScreen()</a>. </p>

</div>
</div>
<a class="anchor" id="a34911cda1cc1bc13336024c844ff4401"></a><!-- doxytag: member="qglviewer::Camera::setPhysicalScreenWidth" ref="a34911cda1cc1bc13336024c844ff4401" args="(float width)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setPhysicalScreenWidth </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>width</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the physical screen (monitor or projected wall) width (in meters). </p>

</div>
</div>
<a class="anchor" id="a212edb01759f542f356c5d62e4a3f821"></a><!-- doxytag: member="qglviewer::Camera::setPosition" ref="a212edb01759f542f356c5d62e4a3f821" args="(const Vec &amp;pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the Camera <a class="el" href="classqglviewer_1_1Camera.html#abc38a05a597e07c9ff525122682adc50">position()</a> (the eye), defined in the world coordinate system. </p>

</div>
</div>
<a class="anchor" id="a546bc081d6116ff848e6fc25a2329e08"></a><!-- doxytag: member="qglviewer::Camera::setRevolveAroundPoint" ref="a546bc081d6116ff848e6fc25a2329e08" args="(const Vec &amp;rap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setRevolveAroundPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rap</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Changes the <a class="el" href="classqglviewer_1_1Camera.html#afd168442e2a05bd41881936fb722b5fe">revolveAroundPoint()</a> to <code>rap</code> (defined in the world coordinate system). </p>

</div>
</div>
<a class="anchor" id="a1710d7aa9fc8dd96f88bba9a1ae3eed7"></a><!-- doxytag: member="qglviewer::Camera::setRevolveAroundPointFromPixel" ref="a1710d7aa9fc8dd96f88bba9a1ae3eed7" args="(const QPoint &amp;pixel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool setRevolveAroundPointFromPixel </td>
          <td>(</td>
          <td class="paramtype">const QPoint &amp;&nbsp;</td>
          <td class="paramname"> <em>pixel</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The <a class="el" href="classqglviewer_1_1Camera.html#afd168442e2a05bd41881936fb722b5fe">revolveAroundPoint()</a> is set to the point located under <code>pixel</code> on screen.</p>
<p>Returns <code>true</code> if a <a class="el" href="classqglviewer_1_1Camera.html#a90459767f782c80086ad7cff90a40b5a">pointUnderPixel()</a> was found. If no point was found under <code>pixel</code>, the <a class="el" href="classqglviewer_1_1Camera.html#afd168442e2a05bd41881936fb722b5fe">revolveAroundPoint()</a> is left unchanged.</p>
<p><code>pixel</code> is expressed in Qt format (origin in the upper left corner of the window). See <a class="el" href="classqglviewer_1_1Camera.html#a90459767f782c80086ad7cff90a40b5a">pointUnderPixel()</a>.</p>
<p>See also <a class="el" href="classqglviewer_1_1Camera.html#a338c3360223f5fb20e2248208d2f32bf">setSceneCenterFromPixel()</a>. </p>

</div>
</div>
<a class="anchor" id="af3a1c2682cba52d6339d2f565ea1d0ee"></a><!-- doxytag: member="qglviewer::Camera::setSceneBoundingBox" ref="af3a1c2682cba52d6339d2f565ea1d0ee" args="(const Vec &amp;min, const Vec &amp;max)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setSceneBoundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>max</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Similar to <a class="el" href="classqglviewer_1_1Camera.html#a33c70507fea15c3ea49a561b743ed822">setSceneRadius()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a9185df6d9e8fbc108f83c5355f5e7b33">setSceneCenter()</a>, but the scene limits are defined by a (world axis aligned) bounding box. </p>

</div>
</div>
<a class="anchor" id="a9185df6d9e8fbc108f83c5355f5e7b33"></a><!-- doxytag: member="qglviewer::Camera::setSceneCenter" ref="a9185df6d9e8fbc108f83c5355f5e7b33" args="(const Vec &amp;center)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setSceneCenter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the <a class="el" href="classqglviewer_1_1Camera.html#a87bccbfd40649310f3da369af02d50b1">sceneCenter()</a>.</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>This method also sets the <a class="el" href="classqglviewer_1_1Camera.html#afd168442e2a05bd41881936fb722b5fe">revolveAroundPoint()</a> to <a class="el" href="classqglviewer_1_1Camera.html#a87bccbfd40649310f3da369af02d50b1">sceneCenter()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a338c3360223f5fb20e2248208d2f32bf"></a><!-- doxytag: member="qglviewer::Camera::setSceneCenterFromPixel" ref="a338c3360223f5fb20e2248208d2f32bf" args="(const QPoint &amp;pixel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool setSceneCenterFromPixel </td>
          <td>(</td>
          <td class="paramtype">const QPoint &amp;&nbsp;</td>
          <td class="paramname"> <em>pixel</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="classqglviewer_1_1Camera.html#a9185df6d9e8fbc108f83c5355f5e7b33">setSceneCenter()</a> to the result of pointUnderPixel(<code>pixel</code>).</p>
<p>Returns <code>true</code> if a <a class="el" href="classqglviewer_1_1Camera.html#a90459767f782c80086ad7cff90a40b5a">pointUnderPixel()</a> was found and <a class="el" href="classqglviewer_1_1Camera.html#a87bccbfd40649310f3da369af02d50b1">sceneCenter()</a> was actually changed.</p>
<p>See also <a class="el" href="classqglviewer_1_1Camera.html#a1710d7aa9fc8dd96f88bba9a1ae3eed7">setRevolveAroundPointFromPixel()</a>. See the <a class="el" href="classqglviewer_1_1Camera.html#a90459767f782c80086ad7cff90a40b5a">pointUnderPixel()</a> documentation. </p>

</div>
</div>
<a class="anchor" id="a33c70507fea15c3ea49a561b743ed822"></a><!-- doxytag: member="qglviewer::Camera::setSceneRadius" ref="a33c70507fea15c3ea49a561b743ed822" args="(float radius)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setSceneRadius </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>radius</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the <a class="el" href="classqglviewer_1_1Camera.html#a58c17044cc4a601c6b446bf5e83513f9">sceneRadius()</a> value. Negative values are ignored.</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>This methods also sets <a class="el" href="classqglviewer_1_1Camera.html#af201ce62f669c8944a276a2615951379">focusDistance()</a> to <a class="el" href="classqglviewer_1_1Camera.html#a58c17044cc4a601c6b446bf5e83513f9">sceneRadius()</a> / tan(<a class="el" href="classqglviewer_1_1Camera.html#a89f1a2e62f7edf51de2d1c077ea5d330">fieldOfView()</a>/2) and <a class="el" href="classqglviewer_1_1Camera.html#ac1758b72dab0895b9340fa833e62b802">flySpeed()</a> to 1% of <a class="el" href="classqglviewer_1_1Camera.html#a58c17044cc4a601c6b446bf5e83513f9">sceneRadius()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a504c573cdd26be8b717a6da9fdb41812"></a><!-- doxytag: member="qglviewer::Camera::setScreenWidthAndHeight" ref="a504c573cdd26be8b717a6da9fdb41812" args="(int width, int height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setScreenWidthAndHeight </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets Camera <a class="el" href="classqglviewer_1_1Camera.html#a80386c5943505b915246563262825d8e">screenWidth()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a9fb925ffbf82e93898ae6db366a8d794">screenHeight()</a> (expressed in pixels).</p>
<p>You should not call this method when the Camera is associated with a <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a>, since the latter automatically updates these values when it is resized (hence overwritting your values).</p>
<p>Non-positive dimension are silently replaced by a 1 pixel value to ensure frustrum coherence.</p>
<p>If your Camera is used without a <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a> (offscreen rendering, shadow maps), use <a class="el" href="classqglviewer_1_1Camera.html#a5b191e9b12b704a05302b5d922792e9c">setAspectRatio()</a> instead to define the projection matrix. </p>

</div>
</div>
<a class="anchor" id="a608e58a2f9fb7e497f91662a6e9ae4cc"></a><!-- doxytag: member="qglviewer::Camera::setType" ref="a608e58a2f9fb7e497f91662a6e9ae4cc" args="(Type type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classqglviewer_1_1Camera.html#a1d1cfd8ffb84e947f82999c682b666a7">Type</a>&nbsp;</td>
          <td class="paramname"> <em>type</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Defines the Camera <a class="el" href="classqglviewer_1_1Camera.html#afbd0fa31db28593e9669c3c56711c0a7">type()</a>.</p>
<p>Changing the camera Type alters the viewport and the objects' size can be changed. This method garantees that the two frustum match in a plane normal to <a class="el" href="classqglviewer_1_1Camera.html#aac10e453c166209b4e6c14c0266651c7">viewDirection()</a>, passing through the Revolve Around Point (RAP).</p>
<p>Prefix the type with <code>Camera</code> if needed, as in: </p>
<div class="fragment"><pre class="fragment">camera()-&gt;setType(<a class="code" href="classqglviewer_1_1Camera.html#a1d1cfd8ffb84e947f82999c682b666a7ae7bf29f117630a30ba5ffc75b33ac624">Camera::ORTHOGRAPHIC</a>); 
<span class="comment">// or even qglviewer::Camera::ORTHOGRAPHIC if you do not use namespace </span>
</pre></div> 
</div>
</div>
<a class="anchor" id="ab442b71a46297223ae12b163653eeb7e"></a><!-- doxytag: member="qglviewer::Camera::setUpVector" ref="ab442b71a46297223ae12b163653eeb7e" args="(const Vec &amp;up, bool noMove=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setUpVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>up</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>noMove</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Rotates the Camera so that its <a class="el" href="classqglviewer_1_1Camera.html#a9cd2e746e7379b08fbaeea0ced76e1d7">upVector()</a> becomes <code>up</code> (defined in the world coordinate system).</p>
<p>The Camera is rotated around an axis orthogonal to <code>up</code> and to the current <a class="el" href="classqglviewer_1_1Camera.html#a9cd2e746e7379b08fbaeea0ced76e1d7">upVector()</a> direction. Use this method in order to define the Camera horizontal plane.</p>
<p>When <code>noMove</code> is set to <code>false</code>, the orientation modification is compensated by a translation, so that the <a class="el" href="classqglviewer_1_1Camera.html#afd168442e2a05bd41881936fb722b5fe">revolveAroundPoint()</a> stays projected at the same position on screen. This is especially useful when the Camera is an observer of the scene (default mouse binding).</p>
<p>When <code>noMove</code> is <code>true</code> (default), the Camera <a class="el" href="classqglviewer_1_1Camera.html#abc38a05a597e07c9ff525122682adc50">position()</a> is left unchanged, which is an intuitive behavior when the Camera is in a walkthrough fly mode (see the <a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875a99906f0ddded6cfdab57271cd33e308c">MOVE_FORWARD</a> and <a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875ab3313fc5887b62fd14b36f1d67903e08">MOVE_BACKWARD</a> <a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875">QGLViewer::MouseAction</a>).</p>
<p>See also <a class="el" href="classqglviewer_1_1Camera.html#a066c4058970a008d0d0a8ff442d117f6">setViewDirection()</a>, <a class="el" href="classqglviewer_1_1Camera.html#aafe147ffa75738c296c729d9b5026446">lookAt()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a3862c502f5afc626af2ff582390bc868">setOrientation()</a>. </p>

</div>
</div>
<a class="anchor" id="a066c4058970a008d0d0a8ff442d117f6"></a><!-- doxytag: member="qglviewer::Camera::setViewDirection" ref="a066c4058970a008d0d0a8ff442d117f6" args="(const Vec &amp;direction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setViewDirection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>direction</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Rotates the Camera so that its <a class="el" href="classqglviewer_1_1Camera.html#aac10e453c166209b4e6c14c0266651c7">viewDirection()</a> is <code>direction</code> (defined in the world coordinate system).</p>
<p>The Camera <a class="el" href="classqglviewer_1_1Camera.html#abc38a05a597e07c9ff525122682adc50">position()</a> is not modified. The Camera is rotated so that the horizon (defined by its <a class="el" href="classqglviewer_1_1Camera.html#a9cd2e746e7379b08fbaeea0ced76e1d7">upVector()</a>) is preserved. See also <a class="el" href="classqglviewer_1_1Camera.html#aafe147ffa75738c296c729d9b5026446">lookAt()</a> and <a class="el" href="classqglviewer_1_1Camera.html#ab442b71a46297223ae12b163653eeb7e">setUpVector()</a>. </p>

</div>
</div>
<a class="anchor" id="a62ab18396bd8c212ec7b90dc156b59d7"></a><!-- doxytag: member="qglviewer::Camera::setZClippingCoefficient" ref="a62ab18396bd8c212ec7b90dc156b59d7" args="(float coef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setZClippingCoefficient </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>coef</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the <a class="el" href="classqglviewer_1_1Camera.html#acd07c1b9464b935ad21bb38b7c27afca">zClippingCoefficient()</a> value. </p>

</div>
</div>
<a class="anchor" id="a1d478610f928ecc4597c56d677d908b5"></a><!-- doxytag: member="qglviewer::Camera::setZNearCoefficient" ref="a1d478610f928ecc4597c56d677d908b5" args="(float coef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setZNearCoefficient </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>coef</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the <a class="el" href="classqglviewer_1_1Camera.html#a4c29c26071ddbe8512d478511e04a93e">zNearCoefficient()</a> value. </p>

</div>
</div>
<a class="anchor" id="ada8dd7d2346ebf46ed1f9822a8418df2"></a><!-- doxytag: member="qglviewer::Camera::showEntireScene" ref="ada8dd7d2346ebf46ed1f9822a8418df2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void showEntireScene </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Moves the Camera so that the entire scene is visible.</p>
<p>Simply calls <a class="el" href="classqglviewer_1_1Camera.html#a424fbe98af0ca295c692d8d4ae73ceec">fitSphere()</a> on a sphere defined by <a class="el" href="classqglviewer_1_1Camera.html#a87bccbfd40649310f3da369af02d50b1">sceneCenter()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a58c17044cc4a601c6b446bf5e83513f9">sceneRadius()</a>.</p>
<p>You will typically use this method in <a class="el" href="classQGLViewer.html#a9339772ec5ac9fa929938109207f2863">QGLViewer::init()</a> after you defined a new <a class="el" href="classqglviewer_1_1Camera.html#a58c17044cc4a601c6b446bf5e83513f9">sceneRadius()</a>. </p>

</div>
</div>
<a class="anchor" id="afbd0fa31db28593e9669c3c56711c0a7"></a><!-- doxytag: member="qglviewer::Camera::type" ref="afbd0fa31db28593e9669c3c56711c0a7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqglviewer_1_1Camera.html#a1d1cfd8ffb84e947f82999c682b666a7">Type</a> type </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the <a class="el" href="classqglviewer_1_1Camera.html#a1d1cfd8ffb84e947f82999c682b666a7">Camera::Type</a> of the Camera.</p>
<p>Set by <a class="el" href="classqglviewer_1_1Camera.html#a608e58a2f9fb7e497f91662a6e9ae4cc">setType()</a>. Mainly used by <a class="el" href="classqglviewer_1_1Camera.html#a98a0679a22f005bbd8cc19756507cc9a">loadProjectionMatrix()</a>.</p>
<p>A <a class="el" href="classqglviewer_1_1Camera.html#a1d1cfd8ffb84e947f82999c682b666a7a2c5d7801888c03752f28943ac85d805f">Camera::PERSPECTIVE</a> Camera uses a classical projection mainly defined by its <a class="el" href="classqglviewer_1_1Camera.html#a89f1a2e62f7edf51de2d1c077ea5d330">fieldOfView()</a>.</p>
<p>With a <a class="el" href="classqglviewer_1_1Camera.html#a1d1cfd8ffb84e947f82999c682b666a7ae7bf29f117630a30ba5ffc75b33ac624">Camera::ORTHOGRAPHIC</a> <a class="el" href="classqglviewer_1_1Camera.html#afbd0fa31db28593e9669c3c56711c0a7">type()</a>, the <a class="el" href="classqglviewer_1_1Camera.html#a89f1a2e62f7edf51de2d1c077ea5d330">fieldOfView()</a> is meaningless and the width and height of the Camera frustum are inferred from the distance to the <a class="el" href="classqglviewer_1_1Camera.html#afd168442e2a05bd41881936fb722b5fe">revolveAroundPoint()</a> using <a class="el" href="classqglviewer_1_1Camera.html#affe84ed52b08d5d1d3dfdb87fe9242fa">getOrthoWidthHeight()</a>.</p>
<p>Both types use <a class="el" href="classqglviewer_1_1Camera.html#a419a57556a6681c3a0489c847d687ea5">zNear()</a> and <a class="el" href="classqglviewer_1_1Camera.html#aa7461df81c1ea0384d4c64723eb7b949">zFar()</a> (to define their clipping planes) and <a class="el" href="classqglviewer_1_1Camera.html#a915589f4d93e15d110444ed9b3464fa1">aspectRatio()</a> (for frustum shape). </p>

</div>
</div>
<a class="anchor" id="a42577d3077e22b4726d78b3db3bba50d"></a><!-- doxytag: member="qglviewer::Camera::unprojectedCoordinatesOf" ref="a42577d3077e22b4726d78b3db3bba50d" args="(const Vec &amp;src, const Frame *frame=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqglviewer_1_1Vec.html">Vec</a> unprojectedCoordinatesOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classqglviewer_1_1Frame.html">Frame</a> *&nbsp;</td>
          <td class="paramname"> <em>frame</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the world unprojected coordinates of a point <code>src</code> defined in the screen coordinate system.</p>
<p>The <code>src.x</code> and <code>src.y</code> input values are expressed in pixels, (0,0) being the <em>upper</em> left corner of the window. <code>src.z</code> is a depth value ranging in [0..1[ (near and far plane respectively). See the <code>gluUnProject</code> man page for details.</p>
<p>The result is expressed in the <code>frame</code> coordinate system. When <code>frame</code> is <code>NULL</code> (default), the result is expressed in the world coordinates system. The possible <code>frame</code> <a class="el" href="classqglviewer_1_1Frame.html#a9794b079db5f492e8804631d3d23baec">Frame::referenceFrame()</a> are taken into account.</p>
<p><a class="el" href="classqglviewer_1_1Camera.html#ac4dc649d17bd2ae8664a7f4fdd50360f">projectedCoordinatesOf()</a> performs the inverse transformation.</p>
<p>This method only uses the intrinsic Camera parameters (see <a class="el" href="classqglviewer_1_1Camera.html#aa1d631d6e368a7aa14656b7511787786">getModelViewMatrix()</a>, <a class="el" href="classqglviewer_1_1Camera.html#a97ff5cf330a6c24d6d49308aedd638bc">getProjectionMatrix()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a5034f21055f864c1ade7d86fec209348">getViewport()</a>) and is completely independent of the OpenGL <code>GL_MODELVIEW</code>, <code>GL_PROJECTION</code> and viewport matrices. You can hence define a virtual Camera and use this method to compute un-projections out of a classical rendering context.</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>However, if your Camera is not attached to a <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a> (used for offscreen computations for instance), make sure the Camera matrices are updated before calling this method (use <a class="el" href="classqglviewer_1_1Camera.html#a0dad4baab6008e5a94e8a2fa83ec0f05">computeModelViewMatrix()</a>, <a class="el" href="classqglviewer_1_1Camera.html#ae51b6c486fe6448453369174bbea8055">computeProjectionMatrix()</a>). See also <a class="el" href="classqglviewer_1_1Camera.html#a504c573cdd26be8b717a6da9fdb41812">setScreenWidthAndHeight()</a>.</dd></dl>
<p>This method is not computationally optimized. If you call it several times with no change in the matrices, you should buffer the entire inverse projection matrix (modelview, projection and then viewport) to speed-up the queries. See the <code>gluUnProject</code> man page for details. </p>

</div>
</div>
<a class="anchor" id="a9cd2e746e7379b08fbaeea0ced76e1d7"></a><!-- doxytag: member="qglviewer::Camera::upVector" ref="a9cd2e746e7379b08fbaeea0ced76e1d7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqglviewer_1_1Vec.html">Vec</a> upVector </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the normalized up vector of the Camera, defined in the world coordinate system.</p>
<p>Set using <a class="el" href="classqglviewer_1_1Camera.html#ab442b71a46297223ae12b163653eeb7e">setUpVector()</a> or <a class="el" href="classqglviewer_1_1Camera.html#a3862c502f5afc626af2ff582390bc868">setOrientation()</a>. It is orthogonal to <a class="el" href="classqglviewer_1_1Camera.html#aac10e453c166209b4e6c14c0266651c7">viewDirection()</a> and to <a class="el" href="classqglviewer_1_1Camera.html#a99f766869c7cc9faaf9a5337db6f223c">rightVector()</a>.</p>
<p>It corresponds to the Y axis of the associated <a class="el" href="classqglviewer_1_1Camera.html#ad367db656b03fe0bc87b021801d66b75">frame()</a> (actually returns <a class="el" href="classqglviewer_1_1Camera.html#ad367db656b03fe0bc87b021801d66b75">frame()</a>-&gt;inverseTransformOf(<a class="el" href="classqglviewer_1_1Vec.html" title="The Vec class represents 3D positions and 3D vectors.">Vec</a>(0.0, 1.0, 0.0)) ). </p>

</div>
</div>
<a class="anchor" id="aac10e453c166209b4e6c14c0266651c7"></a><!-- doxytag: member="qglviewer::Camera::viewDirection" ref="aac10e453c166209b4e6c14c0266651c7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqglviewer_1_1Vec.html">Vec</a> viewDirection </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the normalized view direction of the Camera, defined in the world coordinate system.</p>
<p>Change this value using <a class="el" href="classqglviewer_1_1Camera.html#a066c4058970a008d0d0a8ff442d117f6">setViewDirection()</a>, <a class="el" href="classqglviewer_1_1Camera.html#aafe147ffa75738c296c729d9b5026446">lookAt()</a> or <a class="el" href="classqglviewer_1_1Camera.html#a3862c502f5afc626af2ff582390bc868">setOrientation()</a>. It is orthogonal to <a class="el" href="classqglviewer_1_1Camera.html#a9cd2e746e7379b08fbaeea0ced76e1d7">upVector()</a> and to <a class="el" href="classqglviewer_1_1Camera.html#a99f766869c7cc9faaf9a5337db6f223c">rightVector()</a>.</p>
<p>This corresponds to the negative Z axis of the <a class="el" href="classqglviewer_1_1Camera.html#ad367db656b03fe0bc87b021801d66b75">frame()</a> ( <a class="el" href="classqglviewer_1_1Camera.html#ad367db656b03fe0bc87b021801d66b75">frame()</a>-&gt;inverseTransformOf(<a class="el" href="classqglviewer_1_1Vec.html" title="The Vec class represents 3D positions and 3D vectors.">Vec</a>(0.0, 0.0, -1.0)) ). </p>

</div>
</div>
<a class="anchor" id="a123ad9bda6d715b5370650c2514896ab"></a><!-- doxytag: member="qglviewer::Camera::worldCoordinatesOf" ref="a123ad9bda6d715b5370650c2514896ab" args="(const Vec &amp;src) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqglviewer_1_1Vec.html">Vec</a> worldCoordinatesOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the world coordinates of the point whose position <code>src</code> is defined in the Camera coordinate system.</p>
<p><a class="el" href="classqglviewer_1_1Camera.html#a5dd8eca926558c252d7552d85079880a">cameraCoordinatesOf()</a> performs the inverse transformation. </p>

</div>
</div>
<a class="anchor" id="acd07c1b9464b935ad21bb38b7c27afca"></a><!-- doxytag: member="qglviewer::Camera::zClippingCoefficient" ref="acd07c1b9464b935ad21bb38b7c27afca" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float zClippingCoefficient </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the coefficient used to position the near and far clipping planes.</p>
<p>The near (resp. far) clipping plane is positioned at a distance equal to <a class="el" href="classqglviewer_1_1Camera.html#acd07c1b9464b935ad21bb38b7c27afca">zClippingCoefficient()</a> * <a class="el" href="classqglviewer_1_1Camera.html#a58c17044cc4a601c6b446bf5e83513f9">sceneRadius()</a> in front of (resp. behind) the <a class="el" href="classqglviewer_1_1Camera.html#a87bccbfd40649310f3da369af02d50b1">sceneCenter()</a>. This garantees an optimal use of the z-buffer range and minimizes aliasing. See the <a class="el" href="classqglviewer_1_1Camera.html#a419a57556a6681c3a0489c847d687ea5">zNear()</a> and <a class="el" href="classqglviewer_1_1Camera.html#aa7461df81c1ea0384d4c64723eb7b949">zFar()</a> documentations.</p>
<p>Default value is square root of 3.0 (so that a cube of size <a class="el" href="classqglviewer_1_1Camera.html#a58c17044cc4a601c6b446bf5e83513f9">sceneRadius()</a> is not clipped).</p>
<p>However, since the <a class="el" href="classqglviewer_1_1Camera.html#a58c17044cc4a601c6b446bf5e83513f9">sceneRadius()</a> is used for other purposes (see <a class="el" href="classqglviewer_1_1Camera.html#ada8dd7d2346ebf46ed1f9822a8418df2">showEntireScene()</a>, <a class="el" href="classqglviewer_1_1Camera.html#ac1758b72dab0895b9340fa833e62b802">flySpeed()</a>, ...) and you may want to change this value to define more precisely the location of the clipping planes. See also <a class="el" href="classqglviewer_1_1Camera.html#a4c29c26071ddbe8512d478511e04a93e">zNearCoefficient()</a>.</p>
<p>For a total control on clipping planes' positions, an other option is to overload the <a class="el" href="classqglviewer_1_1Camera.html#a419a57556a6681c3a0489c847d687ea5">zNear()</a> and <a class="el" href="classqglviewer_1_1Camera.html#aa7461df81c1ea0384d4c64723eb7b949">zFar()</a> methods. See the <a href="../examples/standardCamera.html">standardCamera example</a>.</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>When QGLViewer::cameraPathAreEdited(), this value is set to 5.0 so that the Camera paths are not clipped. The previous <a class="el" href="classqglviewer_1_1Camera.html#acd07c1b9464b935ad21bb38b7c27afca">zClippingCoefficient()</a> value is restored back when you leave this mode. </dd></dl>

</div>
</div>
<a class="anchor" id="aa7461df81c1ea0384d4c64723eb7b949"></a><!-- doxytag: member="qglviewer::Camera::zFar" ref="aa7461df81c1ea0384d4c64723eb7b949" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float zFar </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the far clipping plane distance used by the Camera projection matrix.</p>
<p>The far clipping plane is positioned at a distance equal to <a class="el" href="classqglviewer_1_1Camera.html#acd07c1b9464b935ad21bb38b7c27afca">zClippingCoefficient()</a> * <a class="el" href="classqglviewer_1_1Camera.html#a58c17044cc4a601c6b446bf5e83513f9">sceneRadius()</a> behind the <a class="el" href="classqglviewer_1_1Camera.html#a87bccbfd40649310f3da369af02d50b1">sceneCenter()</a>: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="classqglviewer_1_1Camera.html#aa7461df81c1ea0384d4c64723eb7b949">zFar</a> = <a class="code" href="classqglviewer_1_1Camera.html#a253932bd8634348f9c189ab4c9b280b5">distanceToSceneCenter</a>() + <a class="code" href="classqglviewer_1_1Camera.html#acd07c1b9464b935ad21bb38b7c27afca">zClippingCoefficient</a>()*<a class="code" href="classqglviewer_1_1Camera.html#a58c17044cc4a601c6b446bf5e83513f9">sceneRadius</a>();
</pre></div><p>See the <a class="el" href="classqglviewer_1_1Camera.html#a419a57556a6681c3a0489c847d687ea5">zNear()</a> documentation for details. </p>

</div>
</div>
<a class="anchor" id="a419a57556a6681c3a0489c847d687ea5"></a><!-- doxytag: member="qglviewer::Camera::zNear" ref="a419a57556a6681c3a0489c847d687ea5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float zNear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the near clipping plane distance used by the Camera projection matrix.</p>
<p>The clipping planes' positions depend on the <a class="el" href="classqglviewer_1_1Camera.html#a58c17044cc4a601c6b446bf5e83513f9">sceneRadius()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a87bccbfd40649310f3da369af02d50b1">sceneCenter()</a> rather than being fixed small-enough and large-enough values. A good scene dimension approximation will hence result in an optimal precision of the z-buffer.</p>
<p>The near clipping plane is positioned at a distance equal to <a class="el" href="classqglviewer_1_1Camera.html#acd07c1b9464b935ad21bb38b7c27afca">zClippingCoefficient()</a> * <a class="el" href="classqglviewer_1_1Camera.html#a58c17044cc4a601c6b446bf5e83513f9">sceneRadius()</a> in front of the <a class="el" href="classqglviewer_1_1Camera.html#a87bccbfd40649310f3da369af02d50b1">sceneCenter()</a>: </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classqglviewer_1_1Camera.html#a419a57556a6681c3a0489c847d687ea5">zNear</a> = <a class="code" href="classqglviewer_1_1Camera.html#a253932bd8634348f9c189ab4c9b280b5">distanceToSceneCenter</a>() - <a class="code" href="classqglviewer_1_1Camera.html#acd07c1b9464b935ad21bb38b7c27afca">zClippingCoefficient</a>()*<a class="code" href="classqglviewer_1_1Camera.html#a58c17044cc4a601c6b446bf5e83513f9">sceneRadius</a>();
</pre></div><p>In order to prevent negative or too small <a class="el" href="classqglviewer_1_1Camera.html#a419a57556a6681c3a0489c847d687ea5">zNear()</a> values (which would degrade the z precision), <a class="el" href="classqglviewer_1_1Camera.html#a4c29c26071ddbe8512d478511e04a93e">zNearCoefficient()</a> is used when the Camera is inside the <a class="el" href="classqglviewer_1_1Camera.html#a58c17044cc4a601c6b446bf5e83513f9">sceneRadius()</a> sphere: </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">const</span> <span class="keywordtype">float</span> zMin = <a class="code" href="classqglviewer_1_1Camera.html#a4c29c26071ddbe8512d478511e04a93e">zNearCoefficient</a>() * <a class="code" href="classqglviewer_1_1Camera.html#acd07c1b9464b935ad21bb38b7c27afca">zClippingCoefficient</a>() * <a class="code" href="classqglviewer_1_1Camera.html#a58c17044cc4a601c6b446bf5e83513f9">sceneRadius</a>();
 <span class="keywordflow">if</span> (<a class="code" href="classqglviewer_1_1Camera.html#a419a57556a6681c3a0489c847d687ea5">zNear</a> &lt; zMin)
   <a class="code" href="classqglviewer_1_1Camera.html#a419a57556a6681c3a0489c847d687ea5">zNear</a> = zMin;
 <span class="comment">// With an ORTHOGRAPHIC type, the value is simply clamped to 0.0</span>
</pre></div><p>See also the <a class="el" href="classqglviewer_1_1Camera.html#aa7461df81c1ea0384d4c64723eb7b949">zFar()</a>, <a class="el" href="classqglviewer_1_1Camera.html#acd07c1b9464b935ad21bb38b7c27afca">zClippingCoefficient()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a4c29c26071ddbe8512d478511e04a93e">zNearCoefficient()</a> documentations.</p>
<p>If you need a completely different zNear computation, overload the <a class="el" href="classqglviewer_1_1Camera.html#a419a57556a6681c3a0489c847d687ea5">zNear()</a> and <a class="el" href="classqglviewer_1_1Camera.html#aa7461df81c1ea0384d4c64723eb7b949">zFar()</a> methods in a new class that publicly inherits from Camera and use <a class="el" href="classQGLViewer.html#a9c45e1d2c4777de28664d3db952b7585">QGLViewer::setCamera()</a>: </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">class </span>myCamera :: <span class="keyword">public</span> qglviewer::<a class="code" href="classqglviewer_1_1Camera.html#aa3f3efcb2fcc75de885df29041103cd2">Camera</a>
 {
   <span class="keyword">virtual</span> <span class="keywordtype">float</span> <a class="code" href="classqglviewer_1_1Camera.html#a419a57556a6681c3a0489c847d687ea5">Camera::zNear</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0.001; };
   <span class="keyword">virtual</span> <span class="keywordtype">float</span> Camera::zFar()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 100.0; };
 }
</pre></div><p>See the <a href="../examples/standardCamera.html">standardCamera example</a> for an application.</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>The value is always positive although the clipping plane is positioned at a negative z value in the Camera coordinate system. This follows the <code>gluPerspective</code> standard. </dd></dl>

</div>
</div>
<a class="anchor" id="a4c29c26071ddbe8512d478511e04a93e"></a><!-- doxytag: member="qglviewer::Camera::zNearCoefficient" ref="a4c29c26071ddbe8512d478511e04a93e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float zNearCoefficient </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the coefficient which is used to set <a class="el" href="classqglviewer_1_1Camera.html#a419a57556a6681c3a0489c847d687ea5">zNear()</a> when the Camera is inside the sphere defined by <a class="el" href="classqglviewer_1_1Camera.html#a87bccbfd40649310f3da369af02d50b1">sceneCenter()</a> and <a class="el" href="classqglviewer_1_1Camera.html#acd07c1b9464b935ad21bb38b7c27afca">zClippingCoefficient()</a> * <a class="el" href="classqglviewer_1_1Camera.html#a58c17044cc4a601c6b446bf5e83513f9">sceneRadius()</a>.</p>
<p>In that case, the <a class="el" href="classqglviewer_1_1Camera.html#a419a57556a6681c3a0489c847d687ea5">zNear()</a> value is set to <a class="el" href="classqglviewer_1_1Camera.html#a4c29c26071ddbe8512d478511e04a93e">zNearCoefficient()</a> * <a class="el" href="classqglviewer_1_1Camera.html#acd07c1b9464b935ad21bb38b7c27afca">zClippingCoefficient()</a> * <a class="el" href="classqglviewer_1_1Camera.html#a58c17044cc4a601c6b446bf5e83513f9">sceneRadius()</a>. See the <a class="el" href="classqglviewer_1_1Camera.html#a419a57556a6681c3a0489c847d687ea5">zNear()</a> documentation for details.</p>
<p>Default value is 0.005, which is appropriate for most applications. In case you need a high dynamic ZBuffer precision, you can increase this value (~0.1). A lower value will prevent clipping of very close objects at the expense of a worst Z precision.</p>
<p>Only meaningful when Camera type is <a class="el" href="classqglviewer_1_1Camera.html#a1d1cfd8ffb84e947f82999c682b666a7a2c5d7801888c03752f28943ac85d805f">Camera::PERSPECTIVE</a>. </p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
</body>
</html>
